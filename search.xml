<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>场效应管</title>
    <url>/2021/12/28/%E6%A8%A1%E7%94%B5%E7%AC%94%E8%AE%B0/%E5%9C%BA%E6%95%88%E5%BA%94%E7%AE%A1%E9%A2%84%E4%B9%A0%E6%8A%A5%E5%91%8A/</url>
    <content><![CDATA[<h1 id="场效应管"><a href="#场效应管" class="headerlink" title="场效应管"></a>场效应管</h1><p><strong>场效应管是利用输入回路的电场效应来控制输出回路电流的一种半导体器件。</strong>具体怎么控制的，后面再讲。</p>
<p>场效应管的导电特点是：利用多数载流子的定向运动进行导电，因此又称为单极型晶体管。</p>
<p>场效应管按照结构来分类有两种，分别是<strong>结型场效应管和绝缘栅型场效应管</strong>，下面对这两种场效应管的工作原理、特性以及主要参数进行介绍。</p>
<h1 id="结型场效应管"><a href="#结型场效应管" class="headerlink" title="结型场效应管"></a>结型场效应管</h1><p>结型场效应管按照其组成的特点又有两种：<strong>N沟道</strong>和<strong>P沟道</strong>。什么是N沟道，什么是P沟道？其实就像三极管的<code>NPN</code>和<code>PNP</code>类型一样，下面用<strong>N沟道</strong>的场效应管的结构示意图来进一步说明。</p>
<p><img src="https://s2.loli.net/2021/12/27/iKNPMms8kQouRVx.png" alt="image-20211227205315117"></p>
<p>我们看，两块P型半导体夹着一块N型半导体，那么两种半导体的交界面处必然就会产生<strong>PN结</strong>，就类似于三极管一样，同样也会产生耗尽层，耗尽层我们知道，里面只有少量的少子，导电是不可能用它来导电的，那么场效应管怎么导电呢？我们上面说了，场效应管的导电特点是利用多子进行导电，那么，在上面的图中，哪里才有多子？是不是两个耗尽层中间的N型半导体区域？那它怎么导电的？很简单，当我们在上图中D和S两端加上电压，N型半导体里面的多子是不是就会产生定向移动了？那电流就产生了。</p>
<p>那我们这时候看，导电的区域是不是就像形成一条通道一样？那我们就把这条通道就做<strong>导电沟道</strong>。然后导电的区域属于N型半导体区域，那我们<strong>N沟道</strong>的名词就出来了。同样的，如果是两块N型半导体中间夹着一块P型半导体，那么同样按照上面的分析，我们这是就是利用P型半导体里面的多子进行导电，我们就称它为<strong>P沟道</strong>结型场效应管。也就是说，N型半导体导电就叫N沟道，P型半导体导电就叫P沟道。</p>
<h2 id="参数介绍"><a href="#参数介绍" class="headerlink" title="参数介绍"></a>参数介绍</h2><p>那既然已经把导电沟道讲了，那我们把图中的其他参数也一起介绍一下吧。</p>
<p>G：栅极（类似于三极管的B）</p>
<p>S：源极（类似于三极管的E）</p>
<p>D：漏极（类似于三极管的C）</p>
<p>调节G-S之间的反向电压，可以调节耗尽层的宽度，进而影响导电沟道的大小，从而影响通过电流的大小，对电流起阻碍作用。</p>
<p>调节D-S之间的电压，就是调节驱动多子运动的电压，电压增大，电流增大。</p>
<h2 id="工作原理"><a href="#工作原理" class="headerlink" title="工作原理"></a>工作原理</h2><p>大致的原理我们在上面已经讲得差不多了，下面我们就具体的讲一下它是怎么控制输出电流的。</p>
<p>我们上面讲到了，控制通过场效应管的电流有两种方法:控制$U<em>{GS}$和$U</em>{DS}$ ，那我们来用控制变量法来分析一下吧。</p>
<h3 id="首先，我们先不给D-S两端加电压，只调节G-S两端电压"><a href="#首先，我们先不给D-S两端加电压，只调节G-S两端电压" class="headerlink" title="首先，我们先不给D-S两端加电压，只调节G-S两端电压"></a>首先，我们先不给D-S两端加电压，只调节G-S两端电压</h3><ol>
<li><p>当$U_{GS}=0$时，只有PN结自己形成的耗尽层，很小，所以此时导电沟道很宽。</p>
</li>
<li><p>逐渐增大$U_{GS}$,由于在PN结两端加了反向电压，就像下图一样P区的正电荷在外加电场的作用下往左边走，N区的负电荷往右边聚拢，所以中间的耗尽层就会变宽，然后导电沟道就会变窄。</p>
</li>
</ol>
<p><img src="https://s2.loli.net/2021/12/28/6a5Yv79LGWs14Kj.png" alt="image-20211228092716420"></p>
<ol>
<li>我们继续增大$U<em>{GS}$,那么耗尽层也会同时增大，我们不难想到会有这种情况，那就是两边的耗尽层刚好把夹在中间的N型半导体区域完全占据了，这时候我的导电沟道就不存在了，也就没法导电了，我们称这种现象为<strong>夹断</strong>，刚好出现夹断现象的电压$U</em>{GS}$叫做夹断电压，记作$U_{GS(off)}$。</li>
</ol>
<p>   以上三种情况的场效应管的变化结构示意图如下：</p>
<blockquote>
<p>图片来自清华大学华成英课件</p>
</blockquote>
<p>   <img src="https://s2.loli.net/2021/12/28/XC1fDJEs79nZtGb.png" alt="image-20211228094110479"></p>
<h4 id="电阻特性"><a href="#电阻特性" class="headerlink" title="电阻特性"></a>电阻特性</h4><p>我们再来分析上面的三种情况，如果我们在D-S两端加以一定的电压，也就是让导电沟道有电流存在。那么，当$U_{GS}$产生上述的变化时，也就是从0开始逐渐增大，导电沟道的电流会产生什么变化呢？我们已经说过，场效应管导电主要是利用了外加电场对多子的驱动，我们的N沟道结型场效应管就是利用了负电荷的定向移动产生电流，所以这个原理和金属导体导电的原理是一样的。</p>
<p>所以，当我们的沟道变窄的时候，是不是相当于金属导体的导电横截面积变小，那么，我们的单位时间流过导电沟道的电子就变少，电流就变小。所以，我们看，此时场效应管的导电特性是不是和线性电阻是一样的！</p>
<p>也就是说，当场效应管没有产生夹断现象的时候，它呈现的是电阻特性。</p>
<h3 id="给G-S两端加一定电压，调节D-S两端电压"><a href="#给G-S两端加一定电压，调节D-S两端电压" class="headerlink" title="给G-S两端加一定电压，调节D-S两端电压"></a>给G-S两端加一定电压，调节D-S两端电压</h3><p>好，刚才我们是保持$U<em>{DS}$不变，改变$U</em>{GS}$，那这次我们换一下。我们给$U<em>{GS}$一定的电压，它大于0又不会产生夹断现象就行了，我们改变$U</em>{DS}$。</p>
<p>我们从0开始增大$U_{DS}$,我们知道，只要不夹断，效应管就相当于电阻，那么电阻两端的电压越大，电流自然也就越大。</p>
<p>那么，$U_{DS}$可以无限大的大吗？既然这么问了，那也就是说明它大概率是不可能的是吧，那我们下面分析一下原因。</p>
<p>我们要注意到，我们加电压的时候，我们的S端是公共端并且是接地的。那么也就是说，我们的电位$U_G<0$,而$U_D>0$。那么，G和D之间的PN结也是反偏状态的，和上面的图差不多，这里把它搬下来。</p>
<p><img src="https://s2.loli.net/2021/12/28/iJ5BLu3T2DrP8vp.png" alt="image-20211228101251935"></p>
<p>当$U_G$不断增大的时候，G和D之间形成的耗尽层也会越来越宽，就像下面这样子</p>
<p><img src="https://s2.loli.net/2021/12/28/QbJfE6XDI24SaL1.png" alt="image-20211228101517972"></p>
<p>当$U_G$再增大，上面就会出现全是耗尽层的情况，也就是这样子：</p>
<p><img src="https://s2.loli.net/2021/12/28/BmAasDeo5j9Eqw3.png" alt="image-20211228101646014"></p>
<p>我们把这种情况叫做<strong>预夹断</strong>，很明显，这时候$U<em>{GS}=U</em>{GS(off)}$</p>
<p>那我们此时再增大$U_{D}$,情况会怎么样呢？这样耗尽层的宽度就会逐渐变宽，把下面没有夹断的区域慢慢的进行覆盖，就像下面这样：</p>
<p><img src="https://s2.loli.net/2021/12/28/b5JfBp2ja3dtUzi.png" alt="image-20211228103115881"></p>
<p>那我们就来分析一下着这种情况下的电流情况。</p>
<h4 id="恒流特性"><a href="#恒流特性" class="headerlink" title="恒流特性"></a>恒流特性</h4><p>在部分夹断的情况下，我们的电流只能从两边的耗尽层的中间缝隙中通过，为什么呢？因为两边的耗尽层都是正离子，左右两边产生的电场相同，不能把电子吸引到具体的哪一边。</p>
<p>那么，在这种情况下，我再增大$U_D$，电流情况会发生什么样的变化呢？</p>
<p>我们按照上面的分析，知道，此时增大$U_D$,自然纵向电场增强，电流理应变大。</p>
<p>但是，增大$U_D$的时候，夹断区也同时会变大，电子运动的阻力变大，电流理应变小。</p>
<p>那到底是变大还是变小呢？事实上，电流的大小是不变的。上面的两种趋势相互抵消，造成的结果是电流既不变大也不变小，而是保持着恒定的大小。这是我们从外部来看，电流$i_D$的变化与$U_D$无关，表现出恒流特性。</p>
<p>这时候，电流的变化就只与$U<em>{GS}$的大小有关了，也就是$U</em>{GS}$控制电流$i_D$。这就是我们场效应管的特性：利用输入回路的电场效应来控制输出回路电流。</p>
<h2 id="结型场效应管的特性曲线"><a href="#结型场效应管的特性曲线" class="headerlink" title="结型场效应管的特性曲线"></a>结型场效应管的特性曲线</h2><p>我们上面已经把结型场效应管的各个情况下的工作原理进行了说明，下面让我们在来了解一下它的特性曲线，就相当于对上面的内容进行的一个总结。</p>
<h3 id="输出特性曲线"><a href="#输出特性曲线" class="headerlink" title="输出特性曲线"></a>输出特性曲线</h3><p>输出特性曲线反映的是当$U<em>{GS}$一定的情况下，输出电流和电压$U</em>{DS}$之间的关系。这里先给出曲线：</p>
<p><img src="https://s2.loli.net/2021/12/28/W1Twg3hmpIHAYDZ.png" alt="image-20211228105710242"></p>
<p>我们先分析一条曲线，就拿$U_{GS}=-1V$这条曲线来分析。</p>
<p>当$U_{DS}$为0时，$i_D$为0。</p>
<p>当$U_{DS}$慢慢增大，但是还没有达到预夹断状态，此时结型场效应管呈现电阻特性，电压增大，电流增大。</p>
<p>当出现预夹断时，再增大$U_{DS}$，电流$i_D$大小不变，呈现恒流特性。</p>
<p>曲线特性符合我们的分析情况。</p>
<p>那我们再来看一下当$U<em>{DS}$不变的时候，改变$U</em>{GS}$符不符合我们的分析。</p>
<p>当$U<em>{G}$不断变大，$U</em>{GS}$不断变小，耗尽层变宽，导电沟道变窄，电流变小，图中曲线符号我们的分析。</p>
<p>当$U<em>G$不断变大，使得$U</em>{GS}=U_{GS(off)}$的时候，场效应管出现夹断，电流近乎为0。图中曲线也符合。</p>
<p>所以，上面的特征曲线就是我们结型场效应管的输出特性曲线。</p>
<h3 id="转移特性曲线"><a href="#转移特性曲线" class="headerlink" title="转移特性曲线"></a>转移特性曲线</h3><p>转移特性曲线反映的是当$U<em>{DS}$一定并且场效应管工作在恒流区的时候（即$U</em>{GD}&lt;U<em>{GS(off)}$），输出电流和$U</em>{GS}$之间的关系。</p>
<p>其实这个我们上面输出特性也有分析过了，就是在$U<em>{DS}$一定的情况下，把每一点$i_D$对应的$U</em>{GS}$的值映射到坐标平面内然后连线即可。</p>
<p><img src="https://s2.loli.net/2021/12/28/oTVcgnzC2DJh3wI.png" alt="image-20211228111944157"></p>
<h1 id="绝缘栅型场效应管"><a href="#绝缘栅型场效应管" class="headerlink" title="绝缘栅型场效应管"></a>绝缘栅型场效应管</h1><p>绝缘栅型场效应管的栅极与源极、栅极和漏极之间均采用$SiO_2$绝缘层隔离，因此得名。又因为栅极为金属铝，故又称为MOS管（Metal-Oxide-Semiconductor）。</p>
<p>MOS管也有N沟道和P沟道两类，但是按照组成结构的不同，它们又有<strong>增强型</strong>和<strong>耗尽型</strong>两种。</p>
<p>下面我们以N沟道的MOS管为例，分别讲讲增强型和耗尽型MOS管的特性以及它们的工作原理。</p>
<p>首先，我们先明确一下：</p>
<p>当$U_{GS}=0$时，漏极电流也为0，我们把这种管子就做增强型管。</p>
<p>当$U_{GS}=0$时，漏极电流不为0，我们把这种管子叫做耗尽型管。</p>
<p>为什么？我也不知道。</p>
<h2 id="N沟道增强型MOS管"><a href="#N沟道增强型MOS管" class="headerlink" title="N沟道增强型MOS管"></a>N沟道增强型MOS管</h2><h3 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h3><p>它以一块低参杂的P型半导体作为衬底，做两块高参杂的$N^{+}$区域，并引出两个极：s和d，然后半导体上加一块$SiO_2$绝缘层，再在上面加一块铝片引出电极g。结构和符号就像下图这样子。</p>
<p><img src="https://s2.loli.net/2021/12/28/j3vm1d8yRIqGNuw.png" alt="image-20211228163023101"></p>
<h3 id="工作原理-1"><a href="#工作原理-1" class="headerlink" title="工作原理"></a>工作原理</h3><p>绝缘栅型场效应管的导电机制和结型场效应管的是不一样的，我们结型场效应管是利用衬底的多子定向运动导电。而MOS管是利用衬底的少子进行导电。具体原理马上就讲。</p>
<p>那好，我们先来判断这个是什么管子，$U_{GS}$为0，s和d之间不能导电，也就是漏极电流为0，所以这是增强型MOS管。我想，它叫增强型，应该就是需要外部力量来对它进行加强，然后才能进行工作吧。</p>
<p>好，我们来分析它的工作原理。</p>
<p>当给g端加i一个正向电压时，因为有绝缘层的存在，铝片和衬底之间就形成了一个电容，那么铝片上就会积累正电荷，那么就会把衬底中靠近栅极（g）的空穴排斥到下面去，同时会把衬底下面的少子吸引聚集到绝缘板上。那么，空穴被排斥走了就只剩下带负电的离子在哪里了，也就形成了耗尽层。然后，少子在贴着栅极的绝缘板上积聚，当$U_{GS}$足够大时，少子就聚集的足够多，因为少子电性和负离子相同，它们会将耗尽层向下排挤那么一点距离，那么就在绝缘板和耗尽层之间就形成一层少子（也就是电子）的区域，也就是导电沟道，我们把它就做<strong>反型层</strong>。那么这时，s和d之间就可以进行导电啦。</p>
<p>（注意：这里反型层的出现原因是我自己加上去的，属于个人理解，不具备权威性）</p>
<p>我们把这个刚好能够形成导电沟道的电压$U<em>{GS}$叫做开启电压$U</em>{GS(th)}$，很明显的，$U<em>{GS}&gt;U</em>{GS(th)}$时，$U_{GS}$越大，导电沟道（也就是反型层）就越宽。</p>
<p>当我们固定住$U<em>{GS}$，给d和s两端加上一个正向电压，就会产生一个漏极电流。随着$U</em>{DS}$增大，电流也会增大，但是$U<em>{DS}$并不能无线增大，为什么？我们不难发现，形成导电沟道之后，$U</em>{DS}$对漏极电流的影响和结型场效应管的差不多。因为当你在d端加正向电压时，就相当于在右边的PN结两端加了反向电压，那么，靠近d端的耗尽层是会变宽的，那么，沟道就会变窄，电压达到一定的时候，就会产生夹断。那么接下来的分析就和结型场效应管的分析时一摸一样的了。这里给出给出变化趋势图。</p>
<p><img src="https://s2.loli.net/2021/12/28/tnB2y9CXSlfoaJz.png" alt="image-20211228165910889"></p>
<h4 id="特性曲线"><a href="#特性曲线" class="headerlink" title="特性曲线"></a>特性曲线</h4><p><img src="https://s2.loli.net/2021/12/28/H3Y6OwmB4Jg2xzr.png" alt="image-20211228170635614"></p>
<h2 id="N沟道耗尽型场效应管"><a href="#N沟道耗尽型场效应管" class="headerlink" title="N沟道耗尽型场效应管"></a>N沟道耗尽型场效应管</h2><h3 id="结构-1"><a href="#结构-1" class="headerlink" title="结构"></a>结构</h3><p>耗尽型MOS管和增强型差不多，但是增强型只有在$U<em>{GS}&gt;U</em>{GS(th)}$时才有反型层。而耗尽型不需要，为什么？因为耗尽型在SiO_2绝缘层中掺入了大量的正离子，在正离子的作用下P型衬底表面也存在反型层。下面给出它的结构图和符号。</p>
<p><img src="https://s2.loli.net/2021/12/28/QB4txleR7T8YifJ.png" alt="image-20211228171347665"></p>
<h3 id="工作原理-2"><a href="#工作原理-2" class="headerlink" title="工作原理"></a>工作原理</h3><p>当$U<em>{GS}$为正时，增大$U</em>{GS}$反型层变宽。</p>
<p>当$U<em>{GS}$为负时，增大$U</em>{GS}$,反型层变窄，当$U_{GS}$小到一定程度时，反型层消失。</p>
<p>其他的工作和增强型MOS管相同。</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p><img src="https://s2.loli.net/2021/12/28/SdZAiJh8cCwbf9G.png" alt="image-20211228172546919"></p>
<p><img src="https://s2.loli.net/2021/12/28/zykGmxgerCPutcF.png" alt="image-20211228173753533"></p>
]]></content>
      <categories>
        <category>模电笔记</category>
      </categories>
      <tags>
        <tag>场效应管自学笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>201312-3最大的矩形</title>
    <url>/2021/11/13/CCF-CSP/201312-3%E6%9C%80%E5%A4%A7%E7%9A%84%E7%9F%A9%E5%BD%A2/</url>
    <content><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p><a href="http://118.190.20.162/view.page?gpid=T3">题目链接</a></p>
<p><img src="https://i.loli.net/2021/11/12/qnHR1tJwaseWN38.png" alt="image-20211112173121397"></p>
<h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><p>我们可以这样求出我们的最大矩形：<br>对于任意一个矩形<code>h[i]</code>，我们就以它作为高，求出以它为基准的最大的矩形面积。具体怎么做呢？<br>我们可以向左找出比它高的矩形并且是连续的（意思是中间没有一个比它小的），那这样子是不是可以形成一个扁长矩形？<br>同样的，向右找出比它高的矩形并且是连续，那么，以<code>h[i]</code>作为高的最大矩形的面积等于多少不就可以算出来了吗？那我们依次遍历这样的矩形，最大的矩形面积自然也就可以找出来了。</p>
<p>如果不是很能理解的话，看看代码应该就能够懂得了。</p>
<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 最大的矩形 */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">int</span> h[<span class="number">1000</span> + <span class="number">10</span>], d[<span class="number">1000</span> + <span class="number">10</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        cin &gt;&gt; h[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> maxn = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> j = i, k = <span class="number">1</span>;  <span class="comment">// k用于表示以h[i]为高的最大矩形的宽</span></span><br><span class="line">        <span class="keyword">while</span> (j - <span class="number">1</span> &gt;= <span class="number">0</span> &amp;&amp; h[j - <span class="number">1</span>] &gt; h[i]) &#123;</span><br><span class="line">            k++, j--;</span><br><span class="line">        &#125;</span><br><span class="line">        j = i;</span><br><span class="line">        <span class="keyword">while</span> (j + <span class="number">1</span> &lt; n &amp;&amp; h[j + <span class="number">1</span>] &gt; h[i]) &#123;</span><br><span class="line">            k++, j++;</span><br><span class="line">        &#125;</span><br><span class="line">        maxn = <span class="built_in">max</span>(maxn, h[i] * k);</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; maxn;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="后话"><a href="#后话" class="headerlink" title="后话"></a>后话</h1><p>刚开始的时候自己比较懒，又或者自己确实比较菜，就是感觉做不出来，然后就是不想动手写。就去<code>CSDN</code>上面找了答案，然后发现它们贴的标签是<code>单调栈</code>，至于什么是单调栈，现在我还没明白（<del>因为没有去搜</del>），所以这里先做一下标记，等我想起来了在来补充一下单调栈的东西。</p>
]]></content>
      <categories>
        <category>CCF-CSP</category>
      </categories>
      <tags>
        <tag>单调栈</tag>
      </tags>
  </entry>
  <entry>
    <title>201809-2买菜</title>
    <url>/2021/12/03/CCF-CSP/201809-2%E4%B9%B0%E8%8F%9C/</url>
    <content><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p>题目链接：<a href="http://118.190.20.162/view.page?gpid=T78">买菜</a></p>
<p><img src="https://i.loli.net/2021/12/03/qxTMiyLkgJa5uGo.png" alt="image-20211203211821115"></p>
<h1 id="思路：前缀和"><a href="#思路：前缀和" class="headerlink" title="思路：前缀和"></a>思路：前缀和</h1><p>看到题目，第一想法就是<code>前缀和</code>，为什么？因为他要求两人装车的时间重叠的那一部分，然后我们用差分数组对他们装车的时间进行标记，然后两个标记重叠部分就是他们交流的时间。<br>但是，差分时要注意一点，我们差分处理的是一个时间点，而实际的时间是一个时间段，那我们怎么办呢？我们可以采用前闭后开的形式进行差分操作。比如，9点到10点这个时间段，我只对时间点9进行标记，代表一个9点到10点这一个小时。为什么不能右端点也闭合呢？因为如果你对右端点也进行标记的话，假如10点刚好是第一个人装车结束的时间，又是第二个人开始装车的时间，他们这时是不能交流的，但是你算进去了，所以会导致答案的错误。</p>
<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 买菜 */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e6</span> + <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> dif[N],arr[N], n;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123; dif[l]++, dif[r]--; &#125;</span><br><span class="line"><span class="keyword">int</span> s, t;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        cin &gt;&gt; s &gt;&gt; t;</span><br><span class="line">        <span class="built_in">add</span>(s,t);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        cin &gt;&gt; s &gt;&gt; t;</span><br><span class="line">        <span class="built_in">add</span>(s,t);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;N;i++)&#123;</span><br><span class="line">        arr[i]=dif[i]+arr[i<span class="number">-1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> count=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;N;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(arr[i]==<span class="number">2</span>)count++;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; count ;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="不知道前缀和的小伙伴看这里"><a href="#不知道前缀和的小伙伴看这里" class="headerlink" title="不知道前缀和的小伙伴看这里"></a>不知道前缀和的小伙伴看这里</h1><p>不知道前缀和是什么的朋友可以在下面这一篇博文中查看了解哦</p>
<a href="/2021/10/31/%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80/%E5%89%8D%E7%BC%80%E5%92%8C%E4%BB%A5%E5%8F%8A%E5%B7%AE%E5%88%86/" title="前缀和以及差分">前缀和以及差分</a>
]]></content>
      <categories>
        <category>CCF-CSP</category>
      </categories>
      <tags>
        <tag>前缀和</tag>
      </tags>
  </entry>
  <entry>
    <title>201903-2二十四点</title>
    <url>/2021/12/04/CCF-CSP/201903-2%E4%BA%8C%E5%8D%81%E5%9B%9B%E7%82%B9/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>这是一道表达式求值的题目，而且还是简单类型的，上学期老师也有给我们不知过这样的作业，要求比这题还要难一点。但是，在我做的时候，我却傻傻分不清四种运算符的优先级，总是搞乱了。所以，我觉得，我还是有必要写写这一道题的。</p>
<h1 id="题目-带测试样例"><a href="#题目-带测试样例" class="headerlink" title="题目(带测试样例)"></a>题目(带测试样例)</h1><p>题目链接附上：<a href="http://118.190.20.162/view.page?gpid=T88">二十四点</a></p>
<p>这里同样给出题目的截图：</p>
<p><img src="https://s2.loli.net/2021/12/04/UAtJWCNIm4B2Ryq.png" alt="image-20211204193010243"></p>
<h2 id="测试样例"><a href="#测试样例" class="headerlink" title="测试样例"></a>测试样例</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="number">10</span></span><br><span class="line"><span class="number">9</span>+<span class="number">3</span>+<span class="number">4</span>x3</span><br><span class="line"><span class="number">5</span>+<span class="number">4</span>x5x5</span><br><span class="line"><span class="number">7</span><span class="number">-9</span><span class="number">-9</span>+<span class="number">8</span></span><br><span class="line"><span class="number">5</span>x6/<span class="number">5</span>x4</span><br><span class="line"><span class="number">3</span>+<span class="number">5</span>+<span class="number">7</span>+<span class="number">9</span></span><br><span class="line"><span class="number">1</span>x1+<span class="number">9</span><span class="number">-9</span></span><br><span class="line"><span class="number">1</span>x9<span class="number">-5</span>/<span class="number">9</span></span><br><span class="line"><span class="number">8</span>/<span class="number">5</span>+<span class="number">6</span>x9</span><br><span class="line"><span class="number">6</span>x7<span class="number">-3</span>x6</span><br><span class="line"><span class="number">6</span>x4+<span class="number">4</span>/<span class="number">5</span></span><br></pre></td></tr></table></figure>
<h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><p>这个题目是用<code>栈</code>来做的，我的做法是建立一个数字栈和一个符号栈。然后下面我来讲讲我的思路</p>
<p>首先，我们得到的是一个字符串，那么我们要怎样对它就行计算呢？那肯定就要进行转换呀！数字字符就转成我们的数字类型，符号字符就转成我们能操作的运算符类型，这个应该是不用讲的了。那么，我们来关心一下，我们要怎样进行运算呢？</p>
<p>我们回想一下，我们小时候学加减乘除时是不是有一个优先级？比如说先乘除再加减，同级运算从左到右进行·······</p>
<p>好，我们只有四种运算，这两条规则就够了。</p>
<p>我们先把字符串读进来，然后对它进行分析，是数字的话就压进<code>数字栈</code>,是符号的话就压进<code>符号栈</code>，不过，在压符号的时候，我们要注意些什么？没错，注意它的优先级。如果当前的字符的优先级比栈顶元素的低，那我是不是要先把前面的运算执行完了才能压入该符号？为什么？</p>
<p>举个例子，2*3+1，此时，我们判断<code>+</code>该不该压进堆栈，显然不能，因为如果压进堆栈的话，那么我们进行运算的时候是不是会先算3+1？那这就不是我们的正确运算法则了。我们的法则是<code>先乘除，后加减，同级运算从左到右进行</code>，也就是说，就算是同级，我们前面压进的字符也要比你后面压进的字符优先级要高，所以你后面的字符要压进来的话，你要先等我前面的运算完才可以进栈。</p>
<p>好，这样子，我们可以整出一个优先级的表，这个表应该还有更多的符号，我这里只是为了解这一道题，只给出以下四种，等我有时间了在补充写一写<code>表达式求值</code>的内容，到时后再将他们补全吧。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">a\b</th>
<th style="text-align:center">+</th>
<th>-</th>
<th>*</th>
<th>/</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">+</td>
<td style="text-align:center">&gt;</td>
<td>&gt;</td>
<td>&lt;</td>
<td>&lt;</td>
</tr>
<tr>
<td style="text-align:center">-</td>
<td style="text-align:center">&gt;</td>
<td>&gt;</td>
<td>&lt;</td>
<td>&lt;</td>
</tr>
<tr>
<td style="text-align:center">*</td>
<td style="text-align:center">&gt;</td>
<td>&gt;</td>
<td>&gt;</td>
<td>&gt;</td>
</tr>
<tr>
<td style="text-align:center">/</td>
<td style="text-align:center">&gt;</td>
<td>&gt;</td>
<td>&gt;</td>
<td>&gt;</td>
</tr>
</tbody>
</table>
</div>
<blockquote>
<p>表格中的a代表栈顶符号，b代表当前要压入的符号</p>
</blockquote>
<p>这样，我们观察表格就会知道，只有到要压进的符号为<code>*</code>或者<code>/</code>的时候，它才能直接压进去，否则都要将里面有的符号先弹出计算才能压进去。这是一个很好的规律，帮助我们减少代码量。</p>
<p>好，既然已经分析到这里了，我想我们可以动手写代码了。代码里也有相应的注释，不懂的朋友可以看一看代码。</p>
<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 二十四点 */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="comment">/* 运算操作 */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">operate</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">char</span> b, <span class="keyword">int</span> c)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (b == <span class="string">&#x27;+&#x27;</span>) <span class="keyword">return</span> a + c;</span><br><span class="line">    <span class="keyword">if</span> (b == <span class="string">&#x27;-&#x27;</span>) <span class="keyword">return</span> a - c;</span><br><span class="line">    <span class="keyword">if</span> (b == <span class="string">&#x27;x&#x27;</span>) <span class="keyword">return</span> a * c;</span><br><span class="line">    <span class="keyword">if</span> (b == <span class="string">&#x27;/&#x27;</span>) <span class="keyword">return</span> a / c;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    stack&lt;<span class="keyword">int</span>&gt; a;</span><br><span class="line">    stack&lt;<span class="keyword">char</span>&gt; b;</span><br><span class="line">    <span class="keyword">while</span> (n--) &#123;</span><br><span class="line">        string str;</span><br><span class="line">        cin &gt;&gt; str;</span><br><span class="line">        <span class="keyword">int</span> len = str.<span class="built_in">length</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">isdigit</span>(str[i])) &#123;                                    <span class="comment">//如果是数字，压进数字栈</span></span><br><span class="line">                a.<span class="built_in">push</span>(str[i] - <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (b.<span class="built_in">empty</span>())       <span class="comment">//字符栈为空的话直接压栈</span></span><br><span class="line">                    b.<span class="built_in">push</span>(str[i]);</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> ((b.<span class="built_in">top</span>() == <span class="string">&#x27;+&#x27;</span> || b.<span class="built_in">top</span>() == <span class="string">&#x27;-&#x27;</span>) &amp;&amp;        <span class="comment">//如果是字符，判断优先级，如果是特殊的那种情况，直接压栈</span></span><br><span class="line">                         (str[i] == <span class="string">&#x27;x&#x27;</span> || str[i] == <span class="string">&#x27;/&#x27;</span>)) &#123;</span><br><span class="line">                    b.<span class="built_in">push</span>(str[i]);</span><br><span class="line"></span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;                                              <span class="comment">//否则先计算前面的</span></span><br><span class="line">                    <span class="keyword">int</span> num2 = a.<span class="built_in">top</span>();</span><br><span class="line">                    a.<span class="built_in">pop</span>();</span><br><span class="line">                    <span class="keyword">int</span> num1 = a.<span class="built_in">top</span>();</span><br><span class="line">                    a.<span class="built_in">pop</span>();</span><br><span class="line">                    <span class="keyword">char</span> c = b.<span class="built_in">top</span>();</span><br><span class="line">                    b.<span class="built_in">pop</span>();</span><br><span class="line">                    <span class="keyword">int</span> num = <span class="built_in">operate</span>(num1, c, num2);</span><br><span class="line">                    a.<span class="built_in">push</span>(num);</span><br><span class="line">                    b.<span class="built_in">push</span>(str[i]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (!b.<span class="built_in">empty</span>()) &#123;                                      <span class="comment">//将堆栈里面的符号全部拿出来计算</span></span><br><span class="line">            <span class="keyword">int</span> num2 = a.<span class="built_in">top</span>();</span><br><span class="line">            a.<span class="built_in">pop</span>();</span><br><span class="line">            <span class="keyword">int</span> num1 = a.<span class="built_in">top</span>();</span><br><span class="line">            a.<span class="built_in">pop</span>();</span><br><span class="line">            <span class="keyword">char</span> c = b.<span class="built_in">top</span>();</span><br><span class="line">            b.<span class="built_in">pop</span>();</span><br><span class="line">            <span class="keyword">int</span> num = <span class="built_in">operate</span>(num1, c, num2);</span><br><span class="line">            a.<span class="built_in">push</span>(num);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (a.<span class="built_in">top</span>() == <span class="number">24</span>)</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;Yes&quot;</span> &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;No&quot;</span> &lt;&lt; endl;</span><br><span class="line">        a.<span class="built_in">pop</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h1 id="写在最后"><a href="#写在最后" class="headerlink" title="写在最后"></a>写在最后</h1><p>这道题的表达式求值还是很简单的一种形式，推荐大家去把全部的符号都考虑进去，比如括号这些，博主因为时间有限，就不写了（<del>明天就要考试了，五五</del>）。以后有时间的话再来补充<code>表达式求值</code>的内容吧。好，那这道题就到这里，谢谢您的阅读哦。</p>
]]></content>
      <categories>
        <category>CCF-CSP</category>
      </categories>
      <tags>
        <tag>表达式求值</tag>
      </tags>
  </entry>
  <entry>
    <title>201912-1报数</title>
    <url>/2021/12/02/CCF-CSP/201912-1%E6%8A%A5%E6%95%B0/</url>
    <content><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p>题目链接：<a href="http://118.190.20.162/view.page?gpid=T100">报数</a></p>
<p>这里给出题目的截图</p>
<p><img src="https://i.loli.net/2021/12/02/6xCRLDBvPlcWEfI.png" alt="image-20211202172111340"></p>
<h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><p>这个题目很简单，我为什么会写上来呢？因为我真的很菜，做错了好多次（<del>无声哭泣</del>）。</p>
<p>那就来认真分析一下吧。</p>
<p>题目要求我们进行报数是吧，有7的或者是7的倍数的就要求跳过，最后统计出每个人跳过了多少次是吧。</p>
<p>既然只有四个人，那么我们用一个4个长度数组表示他们吧，开一个<code>arr[4]</code>，然后数组具体的值就是他们跳过的次数，为什么可以这样子呢？这个报数的过程其实是一个四个长度的循环，超过4之后又会回来了。也就是说，如果这个数是4的倍数的话，那就刚好会报道第四个人就会结束，那如果不是，那余数就表示当前数是第几个人报的。比如说余数是3，那也就是说，要从头开始报三个人，那刚好就是第三个人报完嘛！</p>
<p>如果报当前数字的人要跳过，我去余数就知道他是第几个人了嘛(余数为0时表示是第4个人)，这样子就可以进行统计啦！也就是执行</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">arr[k%<span class="number">4</span>]++;</span><br></pre></td></tr></table></figure>
<p>假设当前报数为7，那么我们取余，得到3，说明7是第三个人应该报的数，但是他要跳过，所以就是在他的跳过次数上加1.</p>
<p><img src="https://i.loli.net/2021/12/02/QZj1wO6gR8HMhdm.png" alt="image-20211202173045843"></p>
<p>当然，题目还有另外一个考点啦，那就是怎么判断它是7的倍数或者出现了7呢？（<del>我就错在了这里</del>）</p>
<p>7的倍数很简单了，对7取余就行了。</p>
<p>然后就是数字含有7怎么解决，我们采取将它的每一位取出来判断，怎么做呢?那就是不断地除以10，比如说100除以10等于10，再除以10就等于1，就相当于把百位数字取出来了。</p>
<p>好，那讲解就到这里，看代码吧。</p>
<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**&lt; 报数 */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">have_seven</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (x % <span class="number">7</span> == <span class="number">0</span>)<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">	<span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="keyword">while</span> (x) &#123;</span><br><span class="line">			<span class="keyword">if</span> (x % <span class="number">10</span> == <span class="number">7</span>)<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">			x /= <span class="number">10</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">int</span> arr[<span class="number">4</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	cin &gt;&gt; n;</span><br><span class="line">	<span class="keyword">int</span> m = <span class="number">1</span>, k = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">while</span> (m &lt;= n) &#123;</span><br><span class="line">		<span class="keyword">if</span> (<span class="built_in">have_seven</span>(k)) &#123;</span><br><span class="line">			arr[k % <span class="number">4</span>]++;</span><br><span class="line">		&#125; <span class="keyword">else</span> m++;</span><br><span class="line">		k++;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">3</span>; i++) &#123;</span><br><span class="line">		cout &lt;&lt; arr[i] &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	cout &lt;&lt; arr[<span class="number">0</span>];</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h1 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h1><p>哎，没想到自己连这种基础的题目也要写那么久，真的有一点心累了，看来这次认证是不能够达到自己的目标了。努力去考吧，实在不如愿的话来年再考一次。加油吧！</p>
]]></content>
      <categories>
        <category>CCF-CSP</category>
      </categories>
  </entry>
  <entry>
    <title>201912-2回收站选址</title>
    <url>/2021/12/03/CCF-CSP/201912-2%E5%9B%9E%E6%94%B6%E7%AB%99%E9%80%89%E5%9D%80/</url>
    <content><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p>题目链接：<a href="http://118.190.20.162/view.page?gpid=T99">回收站选址</a></p>
<p>以下是题目截图：</p>
<p><img src="https://i.loli.net/2021/12/03/y6XOreuzGMpiqFc.png" alt=""></p>
<h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><p>倦了，看代码。题目挺简单的，按要求做就行。</p>
<p>思路很简单，就是按住一个点不动，一个一个点地去试，看它满不满足垃圾站点的要求，然后再看它有多少分这样子。时间不会卡你的，看数据范围就知道了。</p>
<h1 id="代码-附带样例"><a href="#代码-附带样例" class="headerlink" title="代码(附带样例)"></a>代码(附带样例)</h1><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 回收站选址 */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e3</span> + <span class="number">10</span>;</span><br><span class="line">pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; node[N], location[N];</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, k;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">is_near</span><span class="params">(pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; a, pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> ((a.second == b.second &amp;&amp; <span class="built_in">abs</span>(a.first - b.first) == <span class="number">1</span>) ||</span><br><span class="line">        (a.first == b.first &amp;&amp; <span class="built_in">abs</span>(a.second - b.second) == <span class="number">1</span>))</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">get_score</span><span class="params">(pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; a, pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">abs</span>(a.first - b.first) == <span class="number">1</span> &amp;&amp; <span class="built_in">abs</span>(a.second - b.second) == <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> score[<span class="number">5</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        cin &gt;&gt; node[i].first &gt;&gt; node[i].second;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">is_near</span>(node[i], node[j])) count++;</span><br><span class="line">            <span class="keyword">if</span> (count == <span class="number">4</span>) &#123;</span><br><span class="line">                location[k++] = node[i];</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; k; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++)</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">get_score</span>(location[i], node[j])) count++;<span class="comment">//这里开始时大意了，j对应的数组写成了location</span></span><br><span class="line">        score[count]++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">        cout &lt;&lt; score[i] &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 样例1</span></span><br><span class="line"><span class="comment">7</span></span><br><span class="line"><span class="comment">1 2</span></span><br><span class="line"><span class="comment">2 1</span></span><br><span class="line"><span class="comment">0 0</span></span><br><span class="line"><span class="comment">1 1</span></span><br><span class="line"><span class="comment">1 0</span></span><br><span class="line"><span class="comment">2 0</span></span><br><span class="line"><span class="comment">0 1</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 样例2</span></span><br><span class="line"><span class="comment">2</span></span><br><span class="line"><span class="comment">0 0</span></span><br><span class="line"><span class="comment">-100000 10</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*样例3</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">11</span></span><br><span class="line"><span class="comment">9 10</span></span><br><span class="line"><span class="comment">10 10</span></span><br><span class="line"><span class="comment">11 10</span></span><br><span class="line"><span class="comment">12 10</span></span><br><span class="line"><span class="comment">13 10</span></span><br><span class="line"><span class="comment">11 9</span></span><br><span class="line"><span class="comment">11 8</span></span><br><span class="line"><span class="comment">12 9</span></span><br><span class="line"><span class="comment">10 9</span></span><br><span class="line"><span class="comment">10 11</span></span><br><span class="line"><span class="comment">12 11</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>
<h1 id="写在最后"><a href="#写在最后" class="headerlink" title="写在最后"></a>写在最后</h1><p>写的时候注意看数据范围，刚开始我还以为他会很大，然后卡我时间，然后也就没有想到常规写法，钻进了别的地方去。后面一看，数据范围<code>1e3</code>，那两个循环也就是<code>1e6</code>小于1秒，可以用常规想法呀！</p>
<p>想起宿舍里的那位大佬的话，拿到题，先有思路，然后再动手，实在没有思路也要把暴力的方法写出来。</p>
]]></content>
      <categories>
        <category>CCF-CSP</category>
      </categories>
  </entry>
  <entry>
    <title>202006-1线性分类器</title>
    <url>/2021/11/30/CCF-CSP/202006-1%E7%BA%BF%E6%80%A7%E5%88%86%E7%B1%BB%E5%99%A8/</url>
    <content><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p><a href="http://118.190.20.162/view.page?gpid=T105">题目链接</a></p>
<p>题图：</p>
<p><img src="https://i.loli.net/2021/11/30/WJhmfUzry6QEdL8.png" alt="image-20211130205420497"></p>
<h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><p>在输入的时候就将对应的点分成两类。然后输入直线的时候判断这条直线是不是把这两类点分开了，如果能，那就Yes,否则No.</p>
<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> x, y;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">int</span> m, n;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e3</span>;</span><br><span class="line"><span class="keyword">int</span> k = <span class="number">0</span>, kk = <span class="number">0</span>;</span><br><span class="line">node type1[N], type2[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="keyword">int</span> xi, yi;</span><br><span class="line">    <span class="keyword">char</span> ti;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        cin &gt;&gt; xi &gt;&gt; yi &gt;&gt; ti;</span><br><span class="line">        <span class="keyword">if</span> (ti == <span class="string">&#x27;A&#x27;</span>) &#123;</span><br><span class="line">            type1[k].x = xi, type1[k].y = yi;</span><br><span class="line">            k++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (ti == <span class="string">&#x27;B&#x27;</span>) &#123;</span><br><span class="line">            type2[kk].x = xi, type2[kk].y = yi;</span><br><span class="line">            kk++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> a, b, c;</span><br><span class="line">    <span class="keyword">while</span> (m--) &#123;</span><br><span class="line">        <span class="keyword">int</span> flag = <span class="number">1</span>;</span><br><span class="line">        cin &gt;&gt; a &gt;&gt; b &gt;&gt; c;</span><br><span class="line">        <span class="comment">/* 如果A类点在上面 */</span></span><br><span class="line">        <span class="keyword">if</span> (a + type1[<span class="number">0</span>].x * b + type1[<span class="number">0</span>].y * c &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">/* 检查A类是不是全部在上面 */</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; k; i++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (a + type1[i].x * b + type1[i].y * c &lt;= <span class="number">0</span>) flag = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">/* 检查B类点有没有混到上面的 */</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; kk; i++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (a + type2[i].x * b + type2[i].y * c &gt;= <span class="number">0</span>) flag = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/* A类点在下面 */</span></span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; k; i++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (a + type1[i].x * b + type1[i].y * c &gt;= <span class="number">0</span>) flag = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; kk; i++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (a + type2[i].x * b + type2[i].y * c &lt;= <span class="number">0</span>) flag = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (flag == <span class="number">1</span>)</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;Yes&quot;</span> &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;No&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>CCF-CSP</category>
      </categories>
  </entry>
  <entry>
    <title>202006-2稀疏向量</title>
    <url>/2021/12/01/CCF-CSP/202006-2%E7%A8%80%E7%96%8F%E5%90%91%E9%87%8F/</url>
    <content><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p><a href="http://118.190.20.162/view.page?gpid=T104">稀疏向量</a></p>
<p>题目截图：</p>
<p><img src="https://i.loli.net/2021/12/02/LAERGy4VT6KdOaY.png" alt="image-20211202180655063"></p>
<h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><h2 id="60分答案"><a href="#60分答案" class="headerlink" title="60分答案"></a>60分答案</h2><p>我的第一思路是开一个二维数组，相当于开了一个两行好多列的二维表（为什么说好多列呢?因为主要取决于你那个只有多大)，然后数组下标就表示矩阵下标，然后将他们对应下标的值相乘再相加就能够实现题目要求的内容了。</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 稀疏向量 */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e8</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> arr[<span class="number">2</span>][N];</span><br><span class="line"><span class="keyword">int</span> n, a, b;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> index, value;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; a &gt;&gt; b;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; a; i++) &#123;</span><br><span class="line">        cin &gt;&gt; index &gt;&gt; value;</span><br><span class="line">        arr[<span class="number">0</span>][index]= value;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; b; i++) &#123;</span><br><span class="line">        cin &gt;&gt; index &gt;&gt; value;</span><br><span class="line">        arr[<span class="number">1</span>][index] = value;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        res =arr[<span class="number">0</span>][i] * arr[<span class="number">1</span>][i]+res;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; res;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">10 3 4</span></span><br><span class="line"><span class="comment">4 5</span></span><br><span class="line"><span class="comment">7 -3</span></span><br><span class="line"><span class="comment">10 1</span></span><br><span class="line"><span class="comment">1 10</span></span><br><span class="line"><span class="comment">4 20</span></span><br><span class="line"><span class="comment">5 30</span></span><br><span class="line"><span class="comment">7 40</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>
<p>但是，这个解法只能够拿到60分为什么呢？你看题目要求，他的<code>n</code>的数据范围是到<code>1e9</code>的，但是我们并不能看那么大的数组，所以，对于题目后面四个测试样例，我们就过不了了。所以我们就必须想新的解决办法了。</p>
<h2 id="双指针算法"><a href="#双指针算法" class="headerlink" title="双指针算法"></a>双指针算法</h2><h3 id="废话"><a href="#废话" class="headerlink" title="废话"></a>废话</h3><p>很巧，就在不久前，我也刚刚看了<code>acwing</code>yxc的基础算法课，也刚好看到了他讲的<code>双指针算法</code>，那时本来想写一点笔记的，但是发现那个东西并不好写，然后只能作罢了。在做这道题的时候，我也想到了双指针算法，但是我写的东西还是错的，至于为甚么，后面再讲，还有，我在写题目时还想到了用<code>离散化</code>来做，但自己也是没有写出来。算了，废话就不说了，下面开始讲解：</p>
<h3 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h3><p>我们可以这样子想：对于这两个向量<code>u</code>和<code>v</code>，我们可以用一个结构体来存下它们的有用值的下标（<code>index</code>）以及它的值（<code>value</code>），然后找到这两个向量中下标相等的点，把他们的值相乘再相加就能够得到两个向量的内积了。思路是这样子的，应该也不难理解。然后下面讲讲双指针算法的优势是什么，讲完之后你们对双指针应该也会有一个了解了。</p>
<h4 id="传统处理"><a href="#传统处理" class="headerlink" title="传统处理"></a>传统处理</h4><p>按照我们一贯的思路，我们要找到两个向量中下标相等的值，那么我们可以把一个向量的某一个值暂时确定下来先，也就是作为第一重循环，然后在另一个向量中遍历寻找和该值对应的下标，这是第二重循环。然后我们来分析一下时间复杂度：</p>
<p>两个向量的维度最大可以达到<code>5e5</code>，那么时间复杂度就是$O(n^2)=(5e5)^2=25*e^{10}$，我们大概知道计算机1s能够处理的数据大概是<code>1e8</code> 我们题目要求的时间是2秒，也就是说，我们这么处理数据的话花费的时间是远远超过两秒的，那交上去必然会导致超时。那么这时候就能体现出双指针算法的优越之处了。</p>
<h4 id="双指针算法-1"><a href="#双指针算法-1" class="headerlink" title="双指针算法"></a>双指针算法</h4><p>双指针算法怎么处理数据的呢？</p>
<p>我们分析传统处理方法，我们会发现对于每一个<code>u</code>向量中确定下来的值，我们都要把<code>v</code>中的每一个值无脑地拿出来进行比对。如果我对两个向量中的<code>index</code>从小到大排个序，如果当前<code>u</code>向量的下标（设为<code>i</code>）比<code>v</code>向量下标（设为<code>j</code>）大，那这时我应该要将<code>j</code>移到和<code>i</code>相等的位置才能做出比较，这样我就可以不用理会中间的那些值，也就是说，我的<code>j</code>值是跟这<code>i</code>的值走的。这样就可以让<code>i</code>和<code>j</code>只遍历一遍数组就可以了，这样就能够把传统的$O(n^2)$的算法优化成$O(n)$的了。如果大家不能够理解我上面的描述的话那就琢磨一下代码吧。或这看一下我关于双指针算法的笔记。这里附上链接：<a href="/2021/12/03/%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80/%E5%8F%8C%E6%8C%87%E9%92%88%E7%AE%97%E6%B3%95/" title="双指针算法">双指针算法</a></p>
<h2 id="代码1"><a href="#代码1" class="headerlink" title="代码1"></a>代码1</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">5e5</span> + <span class="number">10</span>;</span><br><span class="line">pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; u[N], v[N];   <span class="comment">//此处pair可以看成是一个结构体，里面有两个元素。但是它和自己定义的结构又有不同，具体百度</span></span><br><span class="line"><span class="keyword">int</span> n, a, b;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	cin &gt;&gt; n &gt;&gt; a &gt;&gt; b;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; a; i++) &#123;</span><br><span class="line">		cin &gt;&gt; u[i].first &gt;&gt; u[i].second;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; b; i++) &#123;</span><br><span class="line">		cin &gt;&gt; v[i].first &gt;&gt; v[i].second;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">sort</span>(u, u + a );</span><br><span class="line">	<span class="built_in">sort</span>(v, v + b );</span><br><span class="line">	<span class="keyword">long</span> <span class="keyword">long</span> res = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>; i &lt; a &amp;&amp; j &lt; b; i++) &#123;</span><br><span class="line">		<span class="keyword">while</span> (j &lt; b &amp;&amp; v[j].first &lt; u[i].first)j++;</span><br><span class="line">		<span class="keyword">if</span> (j &gt;= b)<span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">if</span> (u[i].first == v[j].first)res += u[i].second * v[j].second;</span><br><span class="line">	&#125;</span><br><span class="line">	cout &lt;&lt; res;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="代码2（双指针算法的另一种形式）"><a href="#代码2（双指针算法的另一种形式）" class="headerlink" title="代码2（双指针算法的另一种形式）"></a>代码2（双指针算法的另一种形式）</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 稀疏向量 */</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">5e5</span> + <span class="number">10</span>;</span><br><span class="line">pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; u[N], v[N];</span><br><span class="line"><span class="keyword">int</span> n, a, b;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; a &gt;&gt; b;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= a; i++) &#123;</span><br><span class="line">        cin &gt;&gt; u[i].first &gt;&gt; u[i].second;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= b; i++) &#123;</span><br><span class="line">        cin &gt;&gt; v[i].first &gt;&gt; v[i].second;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">sort</span>(u + <span class="number">1</span>, u + a + <span class="number">1</span>);</span><br><span class="line">    <span class="built_in">sort</span>(v + <span class="number">1</span>, v + b + <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> res = <span class="number">0</span>;</span><br><span class="line">   </span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">1</span>, j = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (i &lt;= a &amp;&amp; j &lt;= b) &#123;</span><br><span class="line">        <span class="keyword">if</span> (u[i].first &gt; v[j].first)</span><br><span class="line">            j++;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (u[i].first &lt; v[j].first)</span><br><span class="line">            i++;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            res += u[i].second * v[j].second;</span><br><span class="line">            i++, j++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (i &lt;= a) &#123;</span><br><span class="line">        <span class="keyword">if</span> (u[i].first == v[b].first) &#123;</span><br><span class="line">            res += u[i].second * v[b].second;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> i++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (j &lt;= b) &#123;</span><br><span class="line">        <span class="keyword">if</span> (u[a].first == v[j].first) &#123;</span><br><span class="line">            res += u[a].second * v[j].second;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> j++;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; res;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="离散化的做法"><a href="#离散化的做法" class="headerlink" title="离散化的做法"></a>离散化的做法</h2><blockquote>
<p>声明：此处的代码不是本人写的，但是我找不到原作者的博客地址了，等找到再加上，如侵删。</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 稀疏向量 */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line">map&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; mp;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n, m1, m2;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> ans = <span class="number">0</span>;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m1 &gt;&gt; m2;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m1; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> num1, num2;</span><br><span class="line">        cin &gt;&gt; num1 &gt;&gt; num2;</span><br><span class="line">        mp[num1] = num2;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m2; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> num1, num2;</span><br><span class="line">        cin &gt;&gt; num1 &gt;&gt; num2;</span><br><span class="line">        ans += mp[num1] * num2;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment">10 3 4</span></span><br><span class="line"><span class="comment">4 5</span></span><br><span class="line"><span class="comment">7 -3</span></span><br><span class="line"><span class="comment">10 1</span></span><br><span class="line"><span class="comment">1 10</span></span><br><span class="line"><span class="comment">4 20</span></span><br><span class="line"><span class="comment">5 30</span></span><br><span class="line"><span class="comment">7 40</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><ol>
<li>双指针算法可以优化传统的双重遍历</li>
<li>注意<code>pair</code>和自己定义的结构体的区别</li>
<li>学习使用一下map来实现离散化，这样不用自己写离散化函数</li>
</ol>
<h1 id="最后的话"><a href="#最后的话" class="headerlink" title="最后的话"></a>最后的话</h1><p>这个题其实不算难吧（写出来后看），但是自己在写的过程中总是不能顺利地实现自己的想法，双指针和离散化我都有尝试过，但还是不能写出来，本来想把自己踩到的坑写一下的，但是没有时间了（<del>写博客真的很费时间</del>）,等我以后休闲一点了在看着上来吧。其实我也已经把坑写到小结那里了，大家查查资料就能够学到了。好吧，那今天就到这里，拜拜啦！</p>
]]></content>
      <categories>
        <category>CCF-CSP</category>
      </categories>
      <tags>
        <tag>双指针算法</tag>
        <tag>离散化</tag>
        <tag>map</tag>
      </tags>
  </entry>
  <entry>
    <title>202009-2风险人群筛查</title>
    <url>/2021/11/02/CCF-CSP/202009-2%E9%A3%8E%E9%99%A9%E4%BA%BA%E7%BE%A4%E7%AD%9B%E6%9F%A5/</url>
    <content><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p>链接：<a href="http://118.190.20.162/view.page?gpid=T112">http://118.190.20.162/view.page?gpid=T112</a></p>
<p><img src="https://i.loli.net/2021/11/02/BaHcCWTrPGln4df.png" alt=""></p>
<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/* 风险人群筛查 */</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">int n, k, t, xl, yd, xr, yu;</span><br><span class="line">int main() &#123;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; k &gt;&gt; t &gt;&gt; xl &gt;&gt; yd &gt;&gt; xr &gt;&gt; yu;</span><br><span class="line">    int res1 = 0, res2 = 0;</span><br><span class="line">    while (n--) &#123;</span><br><span class="line">        bool r1 = false, r2 = false;</span><br><span class="line">        int s = 0;</span><br><span class="line">        for (int i = 0; i &lt; t; i++) &#123;</span><br><span class="line">            int x = 0, y = 0;</span><br><span class="line">            cin &gt;&gt; x &gt;&gt; y;</span><br><span class="line">            if (x &gt;= xl &amp;&amp; x &lt;= xr &amp;&amp; y &gt;= yd &amp;&amp; y &lt;= yu) &#123;</span><br><span class="line">                s++,r1 = true;</span><br><span class="line">                if (s &gt;= k) r2 = true;</span><br><span class="line">            &#125; else</span><br><span class="line">                s = 0;</span><br><span class="line">        &#125;</span><br><span class="line">        if (r1) res1++;</span><br><span class="line">        if (r2) res2++;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; res1 &lt;&lt; endl &lt;&lt; res2;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>这是一道简单题，但是刚开始时我把它想复杂了。想起了之前的朋友跟我说的那句话，在做一道题之前要先进行分析，不要一开始就敲代码，最后只是做无用功。<br>我主要是错在连续在区域内才算逗留那里没有注意，以为就是统计范围里面的个数，所以错了。<br>看了CSDN的一位大佬的解，懂了。主要是用s判断是否连续，如果连续的，s会一直++，只要一不连续，s就会置为0.<br>下面是大佬的地址，推荐去他那里看。</p>
<h1 id="参考内容"><a href="#参考内容" class="headerlink" title="参考内容"></a>参考内容</h1><p><a href="https://blog.csdn.net/qq_52156445/article/details/120260017">https://blog.csdn.net/qq_52156445/article/details/120260017</a></p>
]]></content>
      <categories>
        <category>CCF-CSP</category>
      </categories>
  </entry>
  <entry>
    <title>202012-2期末预测之最佳阈值</title>
    <url>/2021/11/02/CCF-CSP/202012-2%E6%9C%9F%E6%9C%AB%E9%A2%84%E6%B5%8B%E4%B9%8B%E6%9C%80%E4%BD%B3%E9%98%88%E5%80%BC/</url>
    <content><![CDATA[<h1 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h1><p>由于前期在博客园写东西，刚开始没有用markdown来写，所以导致现在博文有点难搬过来了。就直接放博客园的链接代替吧，要看的话请跳转到博客园看。</p>
<p><a href="https://www.cnblogs.com/yongcheng137blogs/p/15367748.html">https://www.cnblogs.com/yongcheng137blogs/p/15367748.html</a></p>
]]></content>
      <categories>
        <category>CCF-CSP</category>
      </categories>
      <tags>
        <tag>前缀和</tag>
        <tag>离散化</tag>
        <tag>sort()排序</tag>
      </tags>
  </entry>
  <entry>
    <title>202109-2非零段划分</title>
    <url>/2021/10/30/CCF-CSP/202109-2%E9%9D%9E%E9%9B%B6%E6%AE%B5%E5%88%92%E5%88%86/</url>
    <content><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p><a href="http://118.190.20.162/view.page?gpid=T130">http://118.190.20.162/view.page?gpid=T130</a></p>
<p>题目图片</p>
<p><img src="https://ycloong.oss-cn-shenzhen.aliyuncs.com/img/picgo/2545058-20211015201238291-2129312433.png" alt="img" style="zoom:80%;" /></p>
<h1 id="思路一：暴力法-70分"><a href="#思路一：暴力法-70分" class="headerlink" title="思路一：暴力法(70分)"></a>思路一：暴力法(70分)</h1><p>我的做法是：先做一个判断非零段的函数，然后依次去p值，将数组中小于p的值置0，将改变后的数组导到一个新的数组中，调用判断函数判断非零段，然后取max值。<br>然后，我判断非零段的方法也很简单，碰到非零的就+1，然后把非零的全部遍历完，再碰到非零的还这样，以此类推……</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e6</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> arr[N],n;</span><br><span class="line"><span class="keyword">int</span> ss[N];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">judge</span><span class="params">(<span class="keyword">int</span> num[], <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (num[i] != <span class="number">0</span>) &#123;</span><br><span class="line">            cnt++;</span><br><span class="line">            <span class="keyword">while</span> (num[i] != <span class="number">0</span>) i++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> cnt;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">maxn</span><span class="params">(<span class="keyword">int</span> num[], <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> maxn = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (num[i] &gt; maxn) maxn = num[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> maxn;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        cin &gt;&gt; arr[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> maxnn = <span class="built_in">maxn</span>(arr, n);</span><br><span class="line">    <span class="keyword">int</span> cnt = <span class="number">0</span>,p=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= maxnn; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (arr[j] &lt; i) ss[j] = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">else</span> ss[j] = arr[j];</span><br><span class="line">        &#125;</span><br><span class="line">        p=<span class="built_in">judge</span>(ss,n);</span><br><span class="line">        cnt=<span class="built_in">max</span>(p,cnt);</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; cnt;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="思路二：前缀和-差分（100分）"><a href="#思路二：前缀和-差分（100分）" class="headerlink" title="思路二：前缀和+差分（100分）"></a>思路二：前缀和+差分（100分）</h1><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e6</span>;</span><br><span class="line"><span class="keyword">int</span> dif[N], a[N];</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123; dif[l]++, dif[r + <span class="number">1</span>]--; &#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) cin &gt;&gt; a[i];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (a[i - <span class="number">1</span>] &lt; a[i]) &#123;</span><br><span class="line">            <span class="built_in">add</span>(a[i - <span class="number">1</span>] + <span class="number">1</span>, a[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> maxn = <span class="number">0</span>, pre = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> p = <span class="number">1</span>; p &lt; <span class="number">1e4</span>; p++) &#123;</span><br><span class="line">        pre += dif[p];</span><br><span class="line">        maxn = <span class="built_in">max</span>(maxn, pre);</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; maxn;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="理解"><a href="#理解" class="headerlink" title="理解"></a>理解</h2><p>这个要用到前缀和以及差分的思想，在这里写的话就显得篇幅太长了，另写博文描述。请看下面的文章：<br><a href="https://www.cnblogs.com/yongcheng137blogs/p/15412952.html">https://www.cnblogs.com/yongcheng137blogs/p/15412952.html</a></p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ol>
<li>在函数内部定义过大的函数时会爆栈，我第一次写的时候（暴力法），每次改变p值时都在循环内定义一个新数组来存储改变后的数组。然后程序也没有报错，但是运行时就是自己中断了，问了大佬才知道原来在还是内部定义太大的数组时会爆栈，所以以后尽量把函数定义在main函数前。</li>
<li>加深理解前缀和，了解了差分这种算法。我发现最近几年CCF的第二题好像都用到了前缀和，要多多练习掌握！</li>
</ol>
]]></content>
      <categories>
        <category>CCF-CSP</category>
      </categories>
      <tags>
        <tag>前缀和</tag>
        <tag>差分</tag>
      </tags>
  </entry>
  <entry>
    <title>kmp算法</title>
    <url>/2021/11/02/%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80/kmp%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<h1 id="什么是kmp算法？"><a href="#什么是kmp算法？" class="headerlink" title="什么是kmp算法？"></a>什么是kmp算法？</h1><p>kmp算法适用于解决模式匹配问题的一个优化的算法，一般是解决字符串匹配的问题。解决字符串匹配问题还有一种算法，那就是BF算法，也就是暴力破解法，但是BF算法比较耗时间，每一次不匹配时都，母串要回溯到开始匹配时的下一个位置，字串要回溯到开始位置，最坏的时间复杂度是O(n&middot;m)。但是，有一些字符串是有一定规律的，就比如下面这个字符串一样:<br><img src="https://i.loli.net/2021/11/02/U2u9AJFVaI4xfks.png" alt="image"><br>当在f这个字符不匹配时，我们会发现，我们可以直接将字串的指针直接移到d的位置，为什么呢？因为f的前面有abc，而刚好d前面也有abc，这表明，在母串上面，已经有一串abc和字串匹配过了，那么，我子串就没有必要在把前面那一截abc在比较一次了。这样子就减少了比较的次数了，从而达到优化的效果。kmp算法就是实现，当当前字符不匹配时，我的指针直接跳到像上面f-&gt;d的效果，从而实现优化。</p>
<hr>
<p><strong>所以，KMP算法适用于解决那些前后都有相同字段的字符串的匹配问题。</strong><br>    按照上面的思路，字符串T[0]  ~   T[k-1]=T[j-k-1]  ~  T[j-1]，这时，我们把T[0]  ~   T[k-1]叫作j的前缀，T[j-k-1]  ~  T[j-1]叫作j的后缀。<strong>也就是说，kmp算法适用于有前缀和后缀的字符串的。</strong></p>
<p>如果T[j]和母串不匹配时，我们要执行的操作是：j=k，也就是j的前缀的下一位，现在，我们做一个这样的数组next，就用来存放当T[j]不匹配时j要走的下一个位置。<br>    然后，我们的问题就转化为了怎么求next数组，也就是说，如果在T[0] ~ T[j-1]的字符中，有T[0] ~ T[k-1]=T[j-k-1] ~ T[j-1]的，那我们就把k存放到next[j]中，这样子当j不匹配时，我们就可以直接跳到k的位置了。那么现在问题就转化为求next数组了。</p>
<h1 id="求next数组"><a href="#求next数组" class="headerlink" title="求next数组"></a>求next数组</h1><p>我们用两个指针k和j对模式串进行遍历，如果，k和j所指的内容相等，我们就把指针都前移，那么这时候，k的大小（+1之后才是）就表示着当前j指针前的字符串的前缀的长度，也就是当j不匹配时，j将要走的位置。上面这句话在代码中实现如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (sub[k] == sub[j]) &#123;</span><br><span class="line">    j++, k++;</span><br><span class="line">    Next[j] = k;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>那如果k和j所指的的容不相等呢？此时分为以下两种情况：</p>
<ol>
<li>k=0，此时，j只能往前走</li>
<li>k&ne;0,此时，k已经往前走了，但是现在不匹配了，也就是说，当前j的前缀已经达到最大，不会再增大了，对于往后的字符，就会有新的前后缀了。那么此时k是不是要从头开始呢，如果k前的字符串没有前后缀的话，确实是这样的。如果有的话，事实上我们把k移到Next[k]就好了。这个过程和子串和母串匹配的过程是一样的。下面给个例子：<br><img src="https://i.loli.net/2021/11/02/izm96owW5TgRSQ1.png" alt="image"><br>k和j不匹配了，那么j的前缀长度（即k的大小+1）又要从小变大了，也就是k要回退。这时，发现k的前缀:agc  和j前面的agc相同，那么我们把k移到T[3]的位置，即相当于前面的acg已经匹配了。在看，上述情况中，Next[k]=3,这不就巧了吗！事实上这不是巧合，这个就是像子串和母串不匹配时的情况是一样的。下面给出以上两种情况的代码：<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(k&gt;<span class="number">0</span>&amp;&amp;sub[k]!=sub[j]</span><br><span class="line">&#123;</span><br><span class="line">    k = Next[k];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(k==<span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">    j++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
所以，Next数组就算求完了。给出完整代码：<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> Next[<span class="number">100</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">getNext</span><span class="params">(string sub)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> k = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> j = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> slen = sub.<span class="built_in">length</span>();</span><br><span class="line">    <span class="keyword">while</span> (j &lt; slen) &#123;</span><br><span class="line">        <span class="keyword">if</span> (sub[k] == sub[j]) &#123;</span><br><span class="line">            j++, k++;</span><br><span class="line">            Next[j] = k;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (k &gt; <span class="number">0</span> &amp;&amp; sub[k] != sub[j]) &#123;</span><br><span class="line">            k = Next[k];</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (k == <span class="number">0</span>) &#123;</span><br><span class="line">            j++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="Next数组优化"><a href="#Next数组优化" class="headerlink" title="Next数组优化"></a>Next数组优化</h1>事实上，上面的的情况时可以优化的。<br> 我们把k=0和k&gt;0时匹配的情况整合起来可以这么做：我们把k的起始值设为-1，然后把Next[0]=-1;先上代码：</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> Next[<span class="number">100</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">getNext</span><span class="params">(string str)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> k = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">int</span> j = <span class="number">0</span>;</span><br><span class="line">    Next[<span class="number">0</span>] = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">int</span> len = str.<span class="built_in">length</span>();</span><br><span class="line">    <span class="keyword">while</span> (j &lt; len) &#123;</span><br><span class="line">        <span class="keyword">if</span> (k == <span class="number">-1</span> || str[k] == str[j]) &#123;</span><br><span class="line">            k++;</span><br><span class="line">            j++;</span><br><span class="line">            Next[j] = k;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            k = Next[k];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>为什么可以这样？<br>我们可以发现，k=0时不匹配以及k!=0时匹配，j都要向前进的。<br>我们把k=-1，Next[0]=-1。刚开始是，k=-1,两个往前走，k=0;j=1;<br>这样子我们就把k=0的情况整合到k，j匹配的情况一同进行了，从而简化代码。</p>
<h1 id="kmp算法实现"><a href="#kmp算法实现" class="headerlink" title="kmp算法实现"></a>kmp算法实现</h1><p>kmp算法最重要的就是求Next数组了，Next数组搞定了，kmp也就实现了，这里直接给代码了。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> Next[<span class="number">100</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">getNext</span><span class="params">(string str)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> k = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">int</span> j = <span class="number">0</span>;</span><br><span class="line">    Next[<span class="number">0</span>] = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">int</span> len = str.<span class="built_in">length</span>();</span><br><span class="line">    <span class="keyword">while</span> (j &lt; len) &#123;</span><br><span class="line">        <span class="keyword">if</span> (k == <span class="number">-1</span> || str[k] == str[j]) &#123;</span><br><span class="line">            k++;</span><br><span class="line">            j++;</span><br><span class="line">            Next[j] = k;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            k = Next[k];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">kmp</span><span class="params">(string momstr, string substr)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> mlen = momstr.<span class="built_in">length</span>();</span><br><span class="line">    <span class="keyword">int</span> slen = substr.<span class="built_in">length</span>();</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">getNext</span>(substr);</span><br><span class="line">    <span class="keyword">while</span> (i &lt; mlen &amp;&amp; j &lt; slen) &#123;</span><br><span class="line">        <span class="keyword">if</span> (j == <span class="number">-1</span> || momstr[i] == substr[j]) &#123;</span><br><span class="line">            i++, j++;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            j = Next[j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (j == slen)</span><br><span class="line">        <span class="keyword">return</span> i - j + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    string momstr, substr;</span><br><span class="line">    cin &gt;&gt; momstr &gt;&gt; substr;</span><br><span class="line">    cout &lt;&lt; <span class="built_in">kmp</span>(momstr, substr);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>到此为止，kmp算法就算讲完了。以上内容仅仅是个人的理解，若有什么不妥当的地方恳请大佬指正！</p>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p><a href="https://www.cnblogs.com/yjiyjige/p/3263858.html" title="详解kmp算法">详解kmp算法</a><br><a href="https://www.bilibili.com/video/BV1Qb411s7tU?from=search&amp;seid=14950803336474153769" title="印度小哥的KMP算法讲解(字幕版)-转自Youtube">印度小哥的KMP算法讲解(字幕版)-转自Youtube</a></p>
]]></content>
      <categories>
        <category>算法基础</category>
      </categories>
      <tags>
        <tag>Kmp</tag>
      </tags>
  </entry>
  <entry>
    <title>前缀和以及差分</title>
    <url>/2021/10/31/%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80/%E5%89%8D%E7%BC%80%E5%92%8C%E4%BB%A5%E5%8F%8A%E5%B7%AE%E5%88%86/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>在写CCF的202109-2题目时，我们宿舍的一位大佬教我怎么使用差分算法来解那道题，可是在他教了我两遍之后，我还是不能理解。然后今天去问了老师，老师跟我说他并没有听说过什么差分！呜呜呜，我当场就懵逼了，老师也给我讲解了一下他的看法，但是我还是不能明白。就在刚刚，我又想了一想，好像突然之间开窍了，好像就理解了，所以我把那题目写了之后，我就接着想把我的理解写出来了，我怕以后我又忘了，又不能理解了，废话不多说了，开始吧！</p>
<h1 id="一维前缀和及差分"><a href="#一维前缀和及差分" class="headerlink" title="一维前缀和及差分"></a>一维前缀和及差分</h1><h2 id="先讲什么是前缀和"><a href="#先讲什么是前缀和" class="headerlink" title="先讲什么是前缀和"></a>先讲什么是前缀和</h2><p>前缀和，就是这个数字及其前面的数的和，也就是 Sm=a[0]+a[1]+a[2]+···+a[i],（a[0]=0,下面b,c同样如此）我们把Sm叫做a[i]的前缀和，然后用一个数组来存储前缀和的话这个数组就叫前缀和数组，例如：<br>b[i]=a[0]+a[1]+a[2]+···+a[i]</p>
<h2 id="再讲差分"><a href="#再讲差分" class="headerlink" title="再讲差分"></a>再讲差分</h2><p>差分就是两数之差，a[i]-a[i-1]，就叫做a[i]的差分，同样，也会有一个差分数组，c[i]=a[i]-a[i-1]</p>
<h2 id="差分数组的性质"><a href="#差分数组的性质" class="headerlink" title="差分数组的性质"></a>差分数组的性质</h2><p><strong>性质一：我们不难发现，差分数组的前缀和就是原数组在当前位置的具体值</strong>，你看：<br>c[1]=a[1]-a[0]<br>c[2]=a[2]-a[1]<br>···<br>c[i]=a[i]-a[i-1]<br>所以，sum=c[1]+c[2]+···+c[i]=a[i]-a[0]=a[i]<br><strong>性质二：*</strong>（不懂怎么表述）<strong>**</strong><br>我们先给一个数组吧<br>a[ ]={0,1,2,3,4,5,6,7,8,9};<br>现在我要对[2,7]范围内的元素都进行+5的操作。那我们当然可以一个一个加，但是这样太麻烦了，我们可以用差分数组来进行操作。设b为a的差分数组，则<br>b[ ]={0,1,1,1,1,1,1,1,1,1};<br>我们对下标为[2,7]的元素都加上5，那么对于2到7的元素来说，他们的差分是不会变的，因为大家都加了5，也就是说，+5这个操作影响的是范围内的值与范围外的值的差分，也就是影响的是临界的时候的差分。<br>所以，只需对差分数组b[2]+5即可，进行前缀和操作时，2以后的数都会+5,但是我们只是想在[2,7]这个范围+5,并不想影响到下标7以后的数，所以，我们执行b[8]-5，这时，求前缀和的时候7以后的数还和原来一样不受影响。<br>处理后的差分数组：<br>b[ ]={0,1,6,1,1,1,1,1,-4,1};<br>求前缀和：<br>a[ ]={0,1,7,8,9,10,11,8,9};<br>你看，这不就相当于对下标[2,7]的数都加上了5嘛！</p>
<p>所以，当我们要对一个范围内的数全体加上或减去某个值时，我们可以对它的差分数组进行操作。具体操作就是：<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r,<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    diff[l]+n, diff[r+<span class="number">1</span>]-n;<span class="comment">//l为下界，r为上界</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>再来一次，对下标为[1,5]的数全体+1，这时执行<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">add</span>(<span class="number">1</span>,<span class="number">5</span>,<span class="number">1</span>);</span><br></pre></td></tr></table></figure><br>这时：<br>b[ ]={0,2,6,1,1,1,0,1,-4,1};<br>a[ ]={0,2,8,9,10,11,11,8,9};<br>同样的，<strong>无论我们执行多少次操作，我们只要对差分数组进行操作即可，最后再对差分数组求前缀和就能得出最后的结果。</strong>这个就是第二个性质。</p>
<h2 id="以CCF-CSP202109-2为例讲解"><a href="#以CCF-CSP202109-2为例讲解" class="headerlink" title="以CCF-CSP202109-2为例讲解"></a>以CCF-CSP202109-2为例讲解</h2><p>题目详细见下面的博文<br><a href="/2021/10/30/CCF-CSP/202109-2%E9%9D%9E%E9%9B%B6%E6%AE%B5%E5%88%92%E5%88%86/" title="202109-2非零段划分">202109-2非零段划分</a></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e6</span>;</span><br><span class="line"><span class="keyword">int</span> dif[N], a[N];</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123; dif[l]++, dif[r + <span class="number">1</span>]--; &#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) cin &gt;&gt; a[i];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (a[i - <span class="number">1</span>] &lt; a[i]) &#123;</span><br><span class="line">            <span class="built_in">add</span>(a[i - <span class="number">1</span>] + <span class="number">1</span>, a[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> maxn = <span class="number">0</span>, pre = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> p = <span class="number">1</span>; p &lt; <span class="number">1e4</span>; p++) &#123;</span><br><span class="line">        pre += dif[p];</span><br><span class="line">        maxn = <span class="built_in">max</span>(maxn, pre);</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; maxn;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>当a[i]&gt;a[i-1]时，当p取到这两个数之间的值时，这里会出现一个非零段，也就是非零段加1，这是不是我们上面所说的对一个范围+某个值？这时候我们执行add(a[i-1]+1,a[i])的意思就是，当p取a[i-1]+1到a[i]这些值的时候，非零段会+1；然后我遍历数组，对满足条件的数同样进行上面的差分操作，也就是<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (a[i - <span class="number">1</span>] &lt; a[i]) &#123;</span><br><span class="line">            <span class="built_in">add</span>(a[i - <span class="number">1</span>] + <span class="number">1</span>, a[i]);</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br></pre></td></tr></table></figure><br>到了最后，我们求dif的前缀和pre=dif[0]+dif[1]+···+dif[p]，这样就可以直接求得dif的最终状态，也就是pre就是当取值为p时的非零段个数。<br><code>pre += dif[p];</code></p>
<p><strong>然后题目要求求出最大的非零段</strong>，用maxn记录最大值即可。</p>
<h1 id="CCF-CSP例题补充解释"><a href="#CCF-CSP例题补充解释" class="headerlink" title="CCF-CSP例题补充解释"></a>CCF-CSP例题补充解释</h1><p>如果a[i-1]&lt;a[i],这意味这什么？</p>
<p>意味着当我的p取到这个范围内的值的时候，非零段会+1</p>
<p>那如果我开一个很大的数组sum，他的下标表示p的取值，它的内容表示当p取得的值是它的下标时我的非零段个数</p>
<p>那是不是说，上述的这个范围里的值都要进行+1的操作，那这是不是对一个范围内的数都进行+1操作，是不是可以运用差分数组来解决了？那么sum的数组是不是就是dif的前缀和，但是题目并没有要求输出每个p时的非零段个数，那么我就没有必要开一个数组了，就用一个pre来表示sum的前缀和。</p>
<hr>
<h1 id="二维前缀和"><a href="#二维前缀和" class="headerlink" title="二维前缀和"></a>二维前缀和</h1><p>假设我们给定义个二维数组a以及一个坐标(x,y）,我们把它左上角的所有元素的和叫做a在（x,y）的前缀和，定义出这样子的一个二维数组，那它就是前缀和数组。</p>
<h2 id="前缀和数组求法"><a href="#前缀和数组求法" class="headerlink" title="前缀和数组求法:"></a>前缀和数组求法:</h2><p><code>sum[x][y]=sum[x-1][y]+sum[x][y-1]+a[x][y];</code></p>
<p>可以用面积来理解，（0，0）-&gt;(x，y)的面积=红色围住的面积+蓝色围住的面积—重叠部分的面积</p>
<p><img src="https://i.loli.net/2021/11/02/RVHbeuE79ONJDjA.png" alt=""></p>
<h2 id="求部分矩阵和"><a href="#求部分矩阵和" class="headerlink" title="求部分矩阵和"></a>求部分矩阵和</h2><p>假设我给出前缀和数组，给定两个点（x1,y1）和（x2,y2），他们分别表示一个矩形的左上角和右下角（x1,y1）和（x2,y2），求两点之间的矩形所有的数的和。理解的话看下图，这里给出具体公式：</p>
<p><code>all=sum[x2][y2]-sum[x2][y1-1]-sum[x1-1,][y2]+sum[x-1][y-1];</code></p>
<p><img src="https://i.loli.net/2021/11/02/xHSc64uYGJUMhOr.png" alt=""></p>
<h1 id="二维差分"><a href="#二维差分" class="headerlink" title="二维差分"></a>二维差分</h1><p>具体差分数组是怎样定义的好像我也不懂，但这并不影响。<br>同样的，二位差分数数组适用的条件也是有范围的，我们在一维差分里，我们应用差分数组的条件是在一个连续段上加上或减去某一个数。<br>在二维中，我们的条件是对一个矩形内的内容进行操作。</p>
<p>下图以及相应引用来自<a href="https://www.acwing.com/user/myspace/index/71847/"><strong>SolitudeAlma</strong></a></p>
<p><img src="https://i.loli.net/2021/11/02/HkNQong3fC52Bcy.png" alt="二维差分"></p>
<blockquote>
<p>从图中我们可以很清楚的看到，如果在x1，y1上加一个数c那么它右下角的数都会加上c，那么该怎么办呢，其实这也是容斥定理。我们只需要减去右边多加的部分和下边多加的部分最后再加上重复减去的部分即可</p>
</blockquote>
<p>所以，我们对二位差分数组进行的操作如下：<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">add</span>(<span class="keyword">int</span> x1,<span class="keyword">int</span> y1,<span class="keyword">int</span> x2,<span class="keyword">int</span> y2,<span class="keyword">int</span> c)&#123;</span><br><span class="line">	dif[x1][y1]+=c,dif[x2+<span class="number">1</span>][y2+<span class="number">1</span>]+=c;</span><br><span class="line">	dif[x2+<span class="number">1</span>][y1]-=c,dif[x1][y1+<span class="number">1</span>]-=c;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><img src="https://i.loli.net/2021/11/02/fjROeWwkcK6Bao1.png" alt=""></p>
<p>我只要在图中带框的位置进行加减操作就不会影响到矩形外的元素了</p>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p><a href="https://www.acwing.com/blog/content/5890/">https://www.acwing.com/blog/content/5890/</a><br><a href="https://chen-ac.blog.csdn.net/article/details/115844025">https://chen-ac.blog.csdn.net/article/details/115844025</a></p>
]]></content>
      <categories>
        <category>算法基础</category>
      </categories>
      <tags>
        <tag>前缀和</tag>
        <tag>差分</tag>
      </tags>
  </entry>
  <entry>
    <title>双指针算法</title>
    <url>/2021/12/03/%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80/%E5%8F%8C%E6%8C%87%E9%92%88%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>听了<code>yxc</code> 在<code>acwing</code>开的基础算法课的其中一节，听了<code>双指针算法</code>，感觉事实上它还是暴力的做法，但是一分析，它居然是一个<code>O(n)</code>的算法，不禁有点好奇，刚开始是有一点搞不懂，总感觉它还是有两层循环，但是一分析，发现它所有的元素顶多遍历了一遍，两个指针最多也就是走了<code>2n</code>次。感觉有点奇妙，因此写了篇笔记。</p>
<h1 id="双指针算法"><a href="#双指针算法" class="headerlink" title="双指针算法"></a>双指针算法</h1><p>我们其实已经接触过双指针算法了，只是我们自己并不知道而已，在哪里接触过呢？没错，再写归并排序的代码的时候以及快速排序的代码的时候。这里，我引用一段归并排序的合并操作 的代码作为例子。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 合并操作 */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span> arr[],<span class="keyword">int</span> l,<span class="keyword">int</span> mid ,<span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> p1=l,p2=mid+<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> help[r-l+<span class="number">1</span>],i=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(p1&lt;=mid &amp;&amp; p2&lt;=r)&#123;</span><br><span class="line">        help[i++]=arr[p1]&lt;=arr[p2]?arr[p1++]:arr[p2++];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* 将没导完的数据导到help */</span></span><br><span class="line">    <span class="keyword">while</span>(p1&lt;=mid)&#123;</span><br><span class="line">        help[i++]=arr[p1++];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(p2&lt;=r)&#123;</span><br><span class="line">        help[i++]=arr[p2++];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* 将help数组拷贝回给arr,注意，合并的是l到r这个区间，并不是0-尽头 */</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">0</span>;k&lt;i;k++)&#123;</span><br><span class="line">        arr[l+k]=help[k];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>归并排序我们的做法是什么？是不是将数组分成两段，然后分别对这两段进行排序，然后将这两段整合到一个数组中，这个整合的过程就用到了双指针算法，我们看上面的代码，我们两个指针<code>p1</code>和<code>p2</code>分别指向排好序的两段，然后我们判断<code>arr[p1]</code>和<code>arr[p2]</code>的值的大小，如果说，<code>arr[p1]</code>小的话，那就把<code>arr[p1]</code>填到中间数组，然后<code>p1</code>就往后移，同样的<code>p2</code>也是如此。也就是说，我们用两个指针就可以把两段排好序的数组有序地排到第三个数组当中来，原理就是，谁小谁就装进去，一直装到完为止。这样，我们会发现，对于左半段的数组上的每一个值，<code>p1</code>都只访问了一遍，同样对于右边的数组，<code>p2</code>也只是访问了一遍。也就是说，将两个排好序的数组(设为<code>数组1</code>和<code>数组2</code>)整合为一个数组（也要求排好序），假设<code>数组1</code>的长度为<code>a</code>,<code>数组2</code>的长度为<code>b</code>,那么整合操作索要进行的操作数最对为<code>a+b</code>。如果我们用固定某个数组的一个值，然后遍历另一个数组的所有值得做法得话，复杂度是<code>O(a*b)</code>，可见，用双指针算法可以达到优化效果。</p>
<h2 id="双指针算法写法"><a href="#双指针算法写法" class="headerlink" title="双指针算法写法"></a>双指针算法写法</h2><p>本来我以为双指针算法只有一种写法，那就是y老师教的那种，但是我看了看归并排序那一题，好像那也是一种写法，而且好像更容易理解。这里把两个模板都给出来吧</p>
<h3 id="这是y老师给的模板："><a href="#这是y老师给的模板：" class="headerlink" title="这是y老师给的模板："></a>这是y老师给的模板：</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>; i &lt; n; i ++ )</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">while</span> (j &lt; b &amp;&amp; <span class="built_in">check</span>(i, j)) j ++ ;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 具体问题的逻辑（题目要求干嘛）</span></span><br><span class="line">&#125;</span><br><span class="line">常见问题分类：</span><br><span class="line">    (<span class="number">1</span>) 对于一个序列，用两个指针维护一段区间</span><br><span class="line">    (<span class="number">2</span>) 对于两个序列，维护某种次序，比如归并排序中合并两个有序序列的操作</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>这里解释一下上面代码的大概意思，就是说，<code>i</code>和<code>j</code>都是从0开始，然后如果<code>j</code>所指的东西满足某种性质的话或者他没有到达边界，那<code>j++</code>，用上面归并排序来说明一下：如果<code>arr[p2]&lt;arr[p1]</code>，那么我把<code>arr[p2]</code>存入<code>help</code>,然后<code>p2++</code>，如果下一个还满足的话，同样执行这样的操作，一直到<code>arr[p2]&gt;=arr[p1]</code>的时候才停止，这时，执行上面操作的就变成<code>p1</code>了，然后知道数组全部判断完毕。这里我改写一下上面归并排序的代码，以方便理解：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 合并操作 */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span> arr[], <span class="keyword">int</span> l, <span class="keyword">int</span> mid, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> help[r - l + <span class="number">1</span>], i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> p1 = l, p2 = mid + <span class="number">1</span>; p1 &lt;= mid; p1++) &#123;</span><br><span class="line">        <span class="keyword">while</span> (arr[p2] &lt; arr[p1] &amp;&amp; p2 &lt;= r) help[i++] = arr[p2++];</span><br><span class="line">        help[i++] = arr[p1];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* 将help数组拷贝回给arr,注意，合并的是l到r这个区间，并不是0-尽头 */</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; i; k++) &#123;</span><br><span class="line">        arr[l + k] = help[k];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="这是另一种形式："><a href="#这是另一种形式：" class="headerlink" title="这是另一种形式："></a>这是另一种形式：</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span>(i&lt;=a&amp;&amp;j&lt;=b)&#123;</span><br><span class="line">    ······</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span>(i&lt;=a)&#123;<span class="comment">//处理i没走完的</span></span><br><span class="line">    ······</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span>(j&lt;=b)&#123;</span><br><span class="line">    ······</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>个人感觉这一种比较好理解</p>
<h1 id="以CCF-CSP，202006-2稀疏向量为例"><a href="#以CCF-CSP，202006-2稀疏向量为例" class="headerlink" title="以CCF-CSP，202006-2稀疏向量为例"></a>以CCF-CSP，202006-2稀疏向量为例</h1><p>在这篇博客中我用了上面两种解法作为例子。大家可以去那边看一看。</p>
<a href="/2021/12/01/CCF-CSP/202006-2%E7%A8%80%E7%96%8F%E5%90%91%E9%87%8F/" title="稀疏向量">稀疏向量</a>
<h1 id="结束"><a href="#结束" class="headerlink" title="结束"></a>结束</h1><p>好了，到这里算是已经写完啦。</p>
]]></content>
      <categories>
        <category>算法基础</category>
      </categories>
      <tags>
        <tag>双指针算法</tag>
      </tags>
  </entry>
  <entry>
    <title>归并排序</title>
    <url>/2021/10/31/%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80/%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F/</url>
    <content><![CDATA[<h2 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h2><h2 id="老师课件"><a href="#老师课件" class="headerlink" title="老师课件"></a>老师课件</h2><p><img src="https://ycloong.oss-cn-shenzhen.aliyuncs.com/img/picgo/image-20211031173908243.png" alt="image-20211031173908243"></p>
<h2 id="思路："><a href="#思路：" class="headerlink" title="思路："></a>思路：</h2><p>采用二分的思想，把一个数组分为左边和右边两部分，我先把左边排好序，右边排好序，最后再将这里边合并就是了。思路就是这样子，那这这时候就有人问了，左边怎么排好序？右边又怎么排好呢？好问题，那我们继续来分析。</p>
<p>第一次分完之后，左边是不是有一段序列了，那我对这段序列排序，是不是同样分成左右两部分，然后继续分啊分，到最后是不是左右两边是不是只剩一个数了？一个数是不是相当于排好了序？好，那这时后我们是不是可以进行合并了呀。</p>
<p>然后，问题又来了，我得到了两个有序的序列，怎么把这两个有序的序列合成一个，并且最后合成的序列也是有序的呢？我们可以这样解决这个问题：</p>
<p>我们弄两个指针<code>p1</code>和<code>p2</code> 分别指向左边部分和右边部分，然后再搞一个额外的数组help，我们比较这两个指针所指的值，谁小就把谁指向的值存入help中，然后它们就向右走，同样，小的值就放到help中，直到最后把左部分和右部分的数全部放到help中，那我们得到的help数组是不是就是左右两边合并后的数组并且是有序？那这不就做到合并操作嘛！好，下面上代码：</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 合并操作 */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span> arr[],<span class="keyword">int</span> l,<span class="keyword">int</span> mid ,<span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> p1=l,p2=mid+<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> help[r-l+<span class="number">1</span>],i=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(p1&lt;=mid &amp;&amp; p2&lt;=r)&#123;</span><br><span class="line">        help[i++]=arr[p1]&lt;=arr[p2]?arr[p1++]:arr[p2++];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* 将没导完的数据导到help */</span></span><br><span class="line">    <span class="keyword">while</span>(p1&lt;=mid)&#123;</span><br><span class="line">        help[i++]=arr[p1++];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(p2&lt;=r)&#123;</span><br><span class="line">        help[i++]=arr[p2++];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* 将help数组拷贝回给arr,注意，合并的是l到r这个区间，并不是0-尽头 */</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">0</span>;k&lt;i;k++)&#123;</span><br><span class="line">        arr[l+k]=help[k];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* 二分操作 */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">process</span><span class="params">(<span class="keyword">int</span> arr[],<span class="keyword">int</span> l,<span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(l==r)&#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> mid = l+((r-l)/<span class="number">2</span>);</span><br><span class="line">    <span class="built_in">process</span>(arr,l,mid);      <span class="comment">//左边部分</span></span><br><span class="line">    <span class="built_in">process</span>(arr,mid+<span class="number">1</span>,r);    <span class="comment">//右边</span></span><br><span class="line">    <span class="built_in">merge</span>(arr,l,mid,r);      <span class="comment">//合并</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* 归并排序 */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">merge_sort</span><span class="params">(<span class="keyword">int</span> arr[],<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="built_in">process</span>(arr,<span class="number">0</span>,n<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="时间复杂度分析"><a href="#时间复杂度分析" class="headerlink" title="时间复杂度分析"></a>时间复杂度分析</h2><p>二分操作 $T(\frac{n}{2})$，<code>process</code>中的基础常数时间操作忽略，只看<code>merge</code> 操作，第一个<code>while</code>循环$O(\frac{n}{2})$ ,第二和第三个循环只会执行其中的一个，复杂度也是$O(\frac{n}{2})$，最后一个循环为$O(n)$ ，所以，最后的时间复杂度：</p>
<p>$T(n)=2T(\frac{n}{2})+O(n)$</p>
<p>应用<code>master</code> 公式，$T(n)=O(n*\log{n})$</p>
<p><code>master</code>  公式不会的请看这篇博文：<a href="/2021/10/30/%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80/%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6/" title="时间复杂度">时间复杂度</a></p>
]]></content>
      <categories>
        <category>算法基础</category>
      </categories>
      <tags>
        <tag>归并排序</tag>
      </tags>
  </entry>
  <entry>
    <title>test</title>
    <url>/2022/05/07/%E9%9A%8F%E7%AC%94/test/</url>
    <content><![CDATA[<h1 id="测试一下"><a href="#测试一下" class="headerlink" title="测试一下"></a>测试一下</h1><p>测试一下文章而已</p>
]]></content>
      <categories>
        <category>随笔</category>
      </categories>
  </entry>
  <entry>
    <title>时间复杂度</title>
    <url>/2021/10/30/%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80/%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6/</url>
    <content><![CDATA[<h1 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h1><h2 id="老师的课件"><a href="#老师的课件" class="headerlink" title="老师的课件"></a>老师的课件</h2><p><img src="https://ycloong.oss-cn-shenzhen.aliyuncs.com/img/picgo/image-20211030203035060.png" alt="image-20211030203035060"></p>
<h2 id="我的理解"><a href="#我的理解" class="headerlink" title="我的理解"></a>我的理解</h2><p>好像没有什么理解的了，就是课件上的内容</p>
<h2 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h2><ol>
<li>big O表示法是去掉低阶项，以及高阶项系数后的表示方法，而且反映的是该算法在最差情况下的复杂度</li>
<li>big O 表示法不能反映出算法程序运行的具体时间，但是能够反映出算法程序与数据量之间的关系</li>
</ol>
<h2 id="讲解"><a href="#讲解" class="headerlink" title="讲解"></a>讲解</h2><p>会根据后面的例题进行讲解</p>
<h1 id="等规模递归情况的时间复杂度（master公式）"><a href="#等规模递归情况的时间复杂度（master公式）" class="headerlink" title="等规模递归情况的时间复杂度（master公式）"></a>等规模递归情况的时间复杂度（master公式）</h1><p>如果递归的子问题是等规模的时候，算递归算法的时间复杂度可以直接套用<code>master</code>公式</p>
<p>假设递归的递推公式如下：</p>
<p><script type="math/tex">T(n)=aT(\frac{n}{a})+O(n^d)</script>则时间复杂度有三种情况：</p>
<ol>
<li>如果$\log_ba&lt;d$，则$T(n)=O(n^d)$</li>
<li>如果$\log_ba&gt;d$ ,  则$T(n)=O(n^{\log_ba})$</li>
<li>如果$\log_ba=d$ ,  则$T(n)=O(n^{d}*\log{n})$</li>
</ol>
]]></content>
      <categories>
        <category>算法基础</category>
      </categories>
      <tags>
        <tag>时间复杂度</tag>
      </tags>
  </entry>
  <entry>
    <title>简单排序算法</title>
    <url>/2021/10/31/%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80/%E7%AE%80%E5%8D%95%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<h1 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h1><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p> 选择排序的实现思路大概是这样子的：</p>
<p>第1轮，我选出最大的值，把它放到数组末端</p>
<p>第2轮，选择第二大的数，把它放到倒数第二个位置</p>
<p>········依此类推</p>
<p>最后一轮，我把最小的数放在第一位，整个数组已经排好序了。</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">select_sort</span><span class="params">(<span class="keyword">int</span> arr[],<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="comment">//第一重循环代表选出第n大的数，也就是要走多少趟，最后一趟不用排了，所以n-1</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=n<span class="number">-1</span>;i&gt;<span class="number">0</span>;i--)&#123;</span><br><span class="line">        <span class="keyword">int</span> maxindex=i;</span><br><span class="line">        <span class="comment">//第二重循环是找出第n大的数，前面已经排好了的i个数就不用管了，所以j=i-1开始</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=i<span class="number">-1</span>;j&gt;=<span class="number">0</span>;j--)&#123;</span><br><span class="line">            maxindex=arr[j]&gt;arr[maxindex]?j:maxindex;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> temp=arr[i];</span><br><span class="line">        arr[i]=arr[maxindex];</span><br><span class="line">        arr[maxindex]=temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="时间复杂度分析"><a href="#时间复杂度分析" class="headerlink" title="时间复杂度分析"></a>时间复杂度分析</h2><p>我们分析上面的代码，在选择排序中，我们会有什么样的常数时间操作呢？</p>
<p>首先，我们要查看<code>arr[j]</code>上的内容，这是一次操作</p>
<p>然后，我们还要比较<code>arr[j]</code>和<code>arr[maxindex]</code>上的内容谁大谁小，这又是一次操作</p>
<p>再然后，我们要进行<code>maxindex</code> 的更新操作，又一次常数时间操作，</p>
<p>这样，我们找出一个第n大的值执行的常数时间操作是：<code>3n</code>,最后还要将第n大的值移到后面，这又是依次常数时间操作，+1</p>
<p>所以，整个算法流程下来，我们执行的常数时间操作次数为：<code>(3n+1)+(3(n-1)+1)+(3(n-2)+1)+···+3(1+1)</code></p>
<p>也就是：<code>3(n+n-1+n-2+···+1)+n</code> 即成等差数列，也就可以表示为$an^2+bn+c$的形式，那由<code>bigO</code>表示法，舍去低阶项，舍去最高阶项的常数系数，然后选择排序的时间复杂度用<code>bigO</code>表示法表示就是: <script type="math/tex">O(n^2)</script></p>
<h1 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h1><h2 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h2><p>冒泡排序的思想大概是这样子的：</p>
<p>对一个数组，依次对比相邻的两个数，大的就换到后面去</p>
<p>就这样比较1轮下来，最大的数已经排到数组的后面去了，那我接下来继续排第2轮，第3轮，···第n轮，这样就能把这个数组排好了。</p>
<h2 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bubble_sort</span><span class="params">(<span class="keyword">int</span> arr[],<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">     <span class="comment">//第一层循环表示要执行多少趟，最后一趟不用执行，所以是n-1</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n<span class="number">-1</span>;i++)&#123;  </span><br><span class="line">         <span class="comment">//第二层循环表示冒泡排序，相邻两数比较，后面已经排好序的就不用再考虑了</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;n-i<span class="number">-1</span>;j++)&#123;  <span class="comment">//注意，数组不能越界</span></span><br><span class="line">            <span class="keyword">if</span>(arr[j]&gt;arr[j+<span class="number">1</span>])&#123;</span><br><span class="line">                <span class="keyword">int</span> temp=arr[j];</span><br><span class="line">                arr[j]=arr[j+<span class="number">1</span>];</span><br><span class="line">                arr[j+<span class="number">1</span>]=temp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="时间复杂度分析-1"><a href="#时间复杂度分析-1" class="headerlink" title="时间复杂度分析"></a>时间复杂度分析</h2><p>基本常数时间操作：查看，比较，交换</p>
<p>那整个算法流程基本常数时间操作就是 $3n+3(n-1)+3(n-2)+···+3$ 也就是 $\frac{n^2}{2}+\frac{n}{2}$ </p>
<p>用大O表示法就是：$O(n^2)$</p>
<p>也就是说，冒泡排序和选择排序的时间复杂度是一样的。</p>
<h1 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h1><h2 id="思想"><a href="#思想" class="headerlink" title="思想"></a>思想</h2><p>插入排序的大致思想是这样子的：</p>
<p>假设<code>0~i</code>上的数是有序的，我再加进来一个数，让新的数组有序，那么，我就拿新加的数和数组上的数（假设位置为j）从后往前比较，如果新加进来的数比j位置的数大，那新的数就加在i面，否则就把新的数加到j前面，也就是和j的数进行交换，一直进行到0的位置或者满足条件的时候为止。最后，新的数组也变得有序了。其实这个算法流程有点像打牌的时候，你新摸一张牌，然后该判断这张牌应该插到那个位置去，当然，前提是你有一个把牌排好序的习惯。</p>
<h2 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">inserttion_sort</span><span class="params">(<span class="keyword">int</span> arr[],<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="comment">//0-0有序</span></span><br><span class="line">    <span class="comment">//下面是实现0-i有序</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;n;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=i;j<span class="number">-1</span>&gt;=<span class="number">0</span>&amp;&amp;arr[j]&lt;arr[j<span class="number">-1</span>];j--)&#123;  <span class="comment">//如果插入的数比当前数要小，就把插入的数放前面</span></span><br><span class="line">            <span class="keyword">int</span> temp=arr[j];</span><br><span class="line">            arr[j]=arr[j<span class="number">-1</span>];</span><br><span class="line">            arr[j<span class="number">-1</span>]=temp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h2><p>基本常数时间操作：查，比，换</p>
<p>这里，具体的时间复杂度和数据的特点有关，当数据一开始就是升序排列，那么时间复杂度是$O(n-1)=O(1)$,如果本身是降序排列，情况最糟，为<script type="math/tex">O(3(1+2+3+···+n-1+n))=O(n^2)</script> 我们说过，bigO表示法是按照最差的情况进行的，所以插入排序的时间复杂度也是$O(n^2)$.</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>上面有三种排序算法，三种算法的时间复杂度都是$O(n^2)$ ,但是，要注意的是，冒泡排序和选择排序的时间复杂度和数据的特点是没有关系的，就算你刚开是就是给了一个升序的数组，它还是会原原本本的按照程序走那么多次。</p>
<p>但是，插入算法是和数据特点有关的，如果你给我一个升序的数组，我只要$O(1)$ 的时间就能走完了，相比于前两个是有优化的。</p>
<p>所以，算法优化的思路与两个方面：</p>
<p><strong>1.数据状况</strong></p>
<p><strong>2.问题性质</strong></p>
]]></content>
      <categories>
        <category>算法基础</category>
      </categories>
      <tags>
        <tag>冒泡排序</tag>
        <tag>选择排序</tag>
        <tag>插入排序</tag>
      </tags>
  </entry>
  <entry>
    <title>勿忘心安</title>
    <url>/2021/12/20/%E9%9A%8F%E7%AC%94/%E5%8B%BF%E5%BF%98%E5%BF%83%E5%AE%89/</url>
    <content><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">
  <script id="hbeData" type="hbeData" data-hmacdigest="8c4275d47e0ac9a33c40c6a9c904861131f6c2ef93e6ab983ad577f3cfbe3267">f1563dec158fb777a094f00121132b8247657c9e529b1634a6dcbaf7f596efe1690cff809c447cd86c04011267f532e5d0c05dca4ed54d7132e81ab0a4eac94c260d1c56ea8b79a8987772427b0ad0cba417b2821cebec26ff91891fbfefee2d23ae6d44e9083e1327396b2515edebb73c8b901d3f94c2bc7079ddda36f015f175dd674f07c2d9397436ea22021ef7920d3a9ffd78634c3b09692c59f6465adce9482920fd937702c10069807c1ecf824bdba4bca83a61ddbf53599fc144da56a4252de0491a4e083c8aba020f867ff45fc2fbc127ebe8edd2c4f3e552013a8341654ddec259779c1b4c3a042d5d8dd96b6176477e0022e8375a0afc997749533b58271318e25925a80c09edc39fd16e011914b4d8063305d09138b87d953e561c4736da0a301fba61e16ffdced5ed9da910fd87d44503bc2e3ae8d6a11312ed104c895e5f8c0a96d9891314672e9a20d43e01e8b03584a2df8b1710dde61e034d2d6f6d22f8a57d1a66edd1e21d72a8b19726fed7060f3dd1f7cbe69491203adab47a0c1ebc7b2622d024fbd5fd35166ef7a048a35a417d0edace4a5bcdbc54d6609ae7062b99140a806ac2d3c907fa896f73102527ff7fc5892439f760c76dd08e7dd02b1ff3da2675f7f281ea91a964648bd0671fe699770983a37ac797f96fa48773d7f28e27732611b35ef9202f2dcde4d0d7425b6f1a7944e05de32b87235b53ab56d8e8bf5d56cdbd58c62f8744d5db5cdaad32d5f47241af65f2ec213029927817a98f5930a4fa284a22f1421f5eaf86a45c3af4cca3a97c0dea747f7185436276fead3a7fefbbaf1bd6a299bb8d647b2e7173b0ab0e0d80caa04549f360c44f5361605fe6d079c58ac3941ca1e5471138fd28cc0a60cc21cca5f5e7ccc89ae9fee3ea456dc62292adbdc0e9c29a33ffcbf9f2e47c5c5c5dd2d0053168e45e96427e790c505a5b070868f37a1a833955f5bcb56d6aee3557e46967387ae479c5bd40bd6cd6dbcec986c1ec2f40c7924431c2f599c5e4a8a6ed220a23d566f5ac1b9e76fa506d21fdea4ad94daab37240ae9be3d90e42abfb26dfc6bb05b2e850fd2b0e3bf0d7df5496cbf85bc40908f34012e5124a7cf1dc89ed7fe60c35220aba6b2f31a776cbe0be97621d5809b91af7992360659c2ea1e5f54d6a19317c1c6d342ea60010b232e5fa48ca49e5e704f63edffbedd5da471085abfe7272eeb3df8a24ea93656bcd9f62719a931fa760b89cffebd3ed2a291b14ae3fbe292a551ab74a79b15cb6e31787970bdd4d1310af5a840e273d306163f249d58d2404928080c47080744e1fd35980bbee77f5caec42e8940de1411159b02d4755d078cc958da34ed702a7d09a41670fe9bbd2438fbf7ade55dc56d193a34f0715a3d11e5adb1b7a90f72784c29e2f3a644cb230b600a4e82d56f2768d43505a71337e9d5e4a6491853c8e867ca59c2d04594137fe93ec25d054ec8cf99738a5fa8723d6c319f057974e6c2fb7e98d2ebdd3b6902c56344fd33a286ee3e2d09fe28f53978ffcebb699d6617d71038004d82d6957b4910bd24661cb011685f12eff0725f8047654ad35fb40803e2eb8b8a8bd73735ef84d917b06afb68a92a983cb8763caf050393082486521f440cf7a8c21b445de2c8f6ac0edbace20a52875198cf548fe5ad886ef5358273409233a8906e990a1b96ad7b4d000a5e23a713750eaf2d1494f45fbb3b8d7758f1acf563ec1bd3f5a8c8ac2d5b5dd6c6f6c015cf8655dd6359bee9b749c6bdcf0bebd7720101ceab8e0cd94bbf7f0fc0442bcecc702973c6f029657ccf625474e3d2fec6861c3b6c02aba0e5746d98fb57d7d32b0661347bc464dce78b186fce371346bf82b34976850f8f7bdeb0d54fb98a09f16da33926ffed353eca43fad7f20fa4d1512322d83eb2d960def3eda732d076981221524052d40a083e6d6a6b76d7abb6997a0063be13a7c459bc3625caeec1f22a3f7b95e6bb0847e8e00e9e9da349759316971eff0fb7578885316ec64aeb203042e4a5a933ca1376151818fec0e84801a5c32a425df086ed8150dec0f4a235b775e2dde64549df3ec4c4cd54070c46f1a4f58881d148945c8669b62063cec9314a9ce38d22143a0721369671ab94e621e4ab1b5a992006a09d4790ab8d7a735070271012bc4d6653d5ccf28aec5a7d7a31c1278559075117cdcda312e630f2b66bc26ff0710d4e86b6f54fafbab3bb0c76b34da45a61e73908ec7f5f0b263cdb45b7cc75382421f8aec25afb45ab034e409382c60e9c2a91efd307354ed1ae6dd029dd6d1c5b1f228598007cb93e47acf4aeab30cbd3e4f2194d237675a786f727362caa58823c3ae673b84c6d70cccf0527796f5f01aca14131f2801ffb77dac20f7692c5ce01b4cba088be04687e26799c1d51a24c27df62bc46bbb460c28dd72954dd116a39889425a1525fb7cf493e7299811883c02bbd9f3e3d2f89c52fff9b01319aca1fafb721a22f3a016571ee9d3fba2b9fb955d8fe1045712bcbdfd48566dfc1a576ab65b6a36dc628218c66b8d5ee7225e11ca807cf1fc0a6bd4fc654fa32068c4c2642a3240bf1f2c78e4075223d9f8b745977e7f4fadf127f2c777e0aaf70dd4f5318279b97d4e749980c750fa7284764dfb5c87f89a75e45a4b34674349275fe77af4b37517e40a50d967bffa6c5dab646301d9fa4ceff4a523842eeea4e45d2ee0c63f897d9babc7029588c4a1c8629038f3f227bd3c13ba67f541d40cb1e66295580db789cd0475f4a01469b97716ed7c4dd79d23c17b25da29f8517e8c68ce84fe32577ba3b388d28b291922ffa847ac0d4ea7db4389ad333b45713ee71c0219da173f1314762b37b00147c8cf890d878e5406bb22d7dbae0675b4ed014ecddd257f84705db5949fcef5c70baeda708626bb9cf43d9879bcfce51b77f08039cf84fe54d05fef7ddbdc56abb0fa925b5ae7922031881747bae744be3cafeb9a6c46f0c07b9ba16ae561f0de1612716b936f5cd31a5f050da413f93d521714959d2f82cd6013f41eed990f66490e1c63f45cc590902aee2806f3a333f403d306c9b3802d6fd55e42d25f300ba3ed4d387a5d3a0e33109be163f1326e53c63343f0f14326d339f3d25d31c9190a1d1252f2730653c6888b8e68d8c8b797242bf492b4f5db99bd0866dc98a349b206a7e60479cfbc39f8153654e8d53a97769285de01af18f470539ce55ee345bd4de74ab475ef4d1c44424a5de3569cc029f0c83ad5c99605bbb7b17baf3ff2f1521ce75e3ba6edd207df2591aac58beed94e92acf1138007729f0d57152a8ca049649e40246f0eecc5c1de5d2f42200c4c3039891a2f5d3abc86483bd06a6a26cb4e75f0002e22f22c152f9849acefd4290169fc708fa9f51a420f69f562eeb370fde3ecaddd6ce9b92570078ca2ef61e5f77bb9cf5fdbf3ad762774b669fd23fd4a8065573972b0f8802131b552223846a0de5f48e205345c556c1b4728cfea215e622e4138adfdd87cb2a03ed7188f72b7367ba899fa2efc6e056f450dcf82f2020e2c67410b5fffee6d6314fec490cb31f6cf5af15f354b0ac1f6b16ee1a003b90955e5edc4de0abc8671cbdd9c0fbd476c80bce3632ab9973adbec388d509803d5bfd95142853a634a7ef7a8b8ed5a47cb889cafd826517b1345c291c7f0434be840b9acc8e67bf5a5248af8303374eaf7881dea8550de338b3b45d46da9de1afb8209d10c0e66a73f53be5ec08cbb9669ce678b604570548213bdd45d85e986144719fe327fa27d73ddfdfd03a2e6f24d257be7227d205fc5caebe6b5354f44d4a407c07d655876b0c9bc5434b145e2ba3a4e1a0a260ba65c439c0b670884f7c98025cd1dad61b4551f47e950ff2a38d24fb0f6994de1084cb9db949c0c4b42c368c44d2814069c79417b5165ce63ee58e5004d37baf6a1ecd45031e6ca7156ece8bd8d85f320f2648904bd7bb3ea89d289bcbd45f25c7409e3c2c05fe924d6fe71e0198da9b918a1ceaa9360a97c0b4c19c7701ad42a5be0a92b393c995ec50ee5cd6e0f7aaaeb3f6f67adcb117e08ee3df3039e98a605c0eb06700ce01217c32a6922605c76753b6571edfee23dcf750c7eac47d8e36accdcd83d93e3a3868b4e78d8302642b2e0880fde8648f5d0e97b83fb865d83fb41ba1608b80b86e647552180c2e33ef4372e5fa81f5bc94f45d216509c9740d6dd32c9b70bdfaf788d93c9695468fdbc21299335174c419fc5e85e781fb97cd15750aa73006e042bce178e9443f34f7f6399154fc283702066296016ae02bd1ac01f5f6257525caf8dd33ba0f8c74abd05d31c069c34893d086387892c77c314a8f3e795f15c47b7502016201c8e77c2db97f0e953430806d07af145fc06f7d362956744ee27ba7942b088dd6d09b89c7ede7918bf04a3e4a4ee59bfcca4601641712740439baa4bfe11edfc01215820b45a2e9e0bd1cb9a73047a507a553d36ff9a10b093976ad7261fd1bc540e75b2a9c2228950cc4c31256b8501653884ac0f70e21b2ad845870c34f0e47b96d8a572f7fa8f9bfd545ffd284ffe5726ffe08bca118171bc5d62b362466b73338b1d174141dba7f10a68166350addee9a1494265f22c3dea8faf5cd173acb5016d3cbaeb42393b4ceab308901438313359411e29c16f70a879274297b6dfe057a363cbfcc997c41ed6068f6187930d112d2811bc58c82409c1d129d8949ff5459069f2cde3d5109c9d98a4d7dc06dfa1bd64c1a0adcc3566e54b37c2fb9fe5475e734974648447332a4bd0b881249007782c8a740f5d913acf18545e80e3c4262128af6eb55ad25d64374ec88f51c449e26ccd0131d7e69e92c7399bb194d25d3e0c4d28d70b7184a2fcafd38fdb48237e0fb4a8eaa31c93b32c1f062e5c49a92490ae9c987c40a08b40f998482f90e377c89332dc0d4476afd8329cbb8c240bb39402acc421ccc2dbe6d15118a76adb8653ec04fd2b2a32c2927e233408c630b97b87226d03d15b7202ba5c2f1d80f4cbf412f8eb98116081ce883a46481b6ff7ebf31dc2670294efdbe7c061e9c3c9a3bc680f7291d6c3b393608fd4d6cd2039707e1703555827ddd5095e6b1a11453840dbcc3baeff031e2929743d9d75b6bb7f453bb81966adfaeaf0627d57aed17d182ad3bb707d7924b59117c6c06f1af479680ecb96f0db4322859a21c158e3fd460c9c06c7501b4f3189497e5652edceb4b8d77fda463d3e152001f84798a12d7817f98aa978a1b2b0147cd6ad6f77260b7e8e64fc5c7641828ea4f37a577f27be154e369b4ac1dbdd37c97d7abcdfa4fffdc1f7c59b3d091cdaa99451029fb1ea62fee11ad9345f732ba904b2d83829873995112e61990ce26e4af8320ceb77fcd0301eb98b704de2b78e7d9916e50bb7b8e8063e8980137ebf23f9f9a10f007218dd3af79471e0548fce5ef1a1d6df34ce3bd7cb9b2fab1243178c3dfa0d8c1768e7ee840504d0a4c0b87fdfb0fb22706a2ea74289f30d0abfc43fe36c07c4af21147a4b7e81120094f45ac33555d64287abd4b4308bf2f5e4808649393dc7162f19e73e1efb4dc3f483cb3fbe988e74f94da32e6d36d98fb51745edce66938c6fe6132a8a77151739d2ad93404a65d5489a77ac971b07d1ba9af66be0c5a04747294af6668bf04cd53a4e71cfc03136c24dc256d3ca633efb7523a74c98840970c48c07347c053985303d88c5d731e8eecf58fa0f3dcd4ee03ec447eea1e610a3d493c677e976efaac1c8d3fc39d700b0d840cce4ed02cdb0c61392159ffb9959dc1f6ca0d8d6b17bbc0afecddf05ea22d60577fb3a8e4669b04f3a50db952a6ac81a9de75b9616bc9d8be64538eb262869c01f3d3ddb77534aab194d68188c23f641e5074a7d69dee5846273be84f5866faf5ea8e4fdde5938cf8bdfe87821c6e0e4d236acfd8ed10b2332a23216a02bdc157d408d18393afa432bedb613bcb4ef13dc58d7c27e0d3212d5b32ae2b7c65285d8c9b14d905f8cd50d3e89aad5ad252859505608065503cc045abee07b068870ace157e2a94346e6c1b3cd78c1942712144b0d1cd792f82f1d3d71a6d9a2914406a115b95c52ee5bf905379396a58b11562f0d54ef3f78bcc151b8f346131b94d66ebb07009a2b3eae6e217dc3c8715e91e0bc16b9ead4d3f4dff84927953eab05e5715bd8bdacc6fa81d372c8256790c9f63c5f46880dd2ec955ad90055a4f20dc9d7e7de01451c00e1a99c69c55dd1122e8d382a1a77b36fd8d8c7530dadf3c0cf14e94c79ab45cd22036b75c46b6b5f633aea09b83033d340a33b03ee350b03898026ba965c6241e974abf33700fb9171b8260a42206d5f900569a9b397949cf71012d144616dafc8647e6d3c9f03f6b0f0b12df9d2599267a92eeabe1dffea92f115aedb8772d2a592d5980d2e3b74a300f9d95de77c72b9ae050b4daf852593788153f37614bcf731a592c2e1c115430bf6dfb567ddde98c6420a3466a8b3b2d0117c1a534915f25d36289ec47e41575cb801dff682490877b9fdedb2b8522dd2d12c6660b31d86f50d0da2f1421c1edcf0236515898cb34f8b6657272a157a207de888a66afc3d03584b1e6e84e79471ab9cbff170752356c1a3b3ba56f5c3ceda8d4a70b1f1543345038b53733d81c58a8a52183be896f4441b2c9ead1663bfc6bd107bfb3bdbb8702b0def5338f54a6be4e92815b9700cafb582569524fe466a025c2c323b4f265ae0ac3d8f7b729f34fac6dd26be14de18f95d3a4bb9b63c545dd8c66f569560e34cb69652aab00b14a039e550c5436852282695ba5100be2eb1e9b0ccd0bb3863d26f637e00949d329e34c404cbae802e0a106ad43d0e69fa577453ae5417c3777d08f8a9341659336b6def775082e18cf4cde089f49f43db131727dc4c144f3f878a5937f5898a15218dab02f6b3538df6a9c517a9f7ea4e887c744f21d4b88406109f1223a4de2bf376993ef9ee99cc193be8cd2849c10ab13c3090c2d63686c58c2166a4f5ecbea1d2992d0062685c29f66e93cd36d32758b6f7f25b574970bc58737b46ea3cf1a3a5686b1977bb617ab7ada876085928e48d20672a106439f863d20036ec1f0c997e00e204a48035cee7192e4699298213cf24dd9711b8820567377b1cad7ff0c24533ecf1896d4c176ce274458e3ae8d2f011dcaf69553cf2ce33107b9c4481086f57216851a626222adfd0174af8b4a9bad09741fa11b4d6f48417832c81ce8f54337f1202a8c94628919c8e4565a205bfae2ea90c3d65154fea21ca41b3e9749693506488f85b656b11db120a6c552b3ddf56d0939569a4a0c8680f5f21895df86fd3149438ddffb746fe0352711fee18dbabf897c74dcb15b7b976fc3cf4c38d9325bf8803ecc3</script>
  <div class="hbe hbe-content">
    <div class="hbe hbe-input hbe-input-default">
      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">
      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">
        <span class="hbe hbe-input-label-content hbe-input-label-content-default">请输入密码</span>
      </label>
    </div>
  </div>
</div>
<script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
      <categories>
        <category>随笔</category>
      </categories>
  </entry>
  <entry>
    <title>文章更新计划</title>
    <url>/2022/05/07/%E9%9A%8F%E7%AC%94/%E6%96%87%E7%AB%A0%E6%9B%B4%E6%96%B0%E8%AE%A1%E5%88%92/</url>
    <content><![CDATA[<p>看了看归档，惊奇的发现自己已经有差不多半年没有更新过文章了。其实这段时间确实也是忙，，但是懒也确实是懒。虽然文章更新了也不会有人看，但是，我写博客的初心并不是这个。我写博客的初心是想记录自己的成长，而不是博得他人开心。</p>
<p>所以，鉴于此，我只能对自己说：你堕落了！</p>
<p>好了，现在比赛也已经比完了，你也没有什么好说的了，快点来打理打理你这荒芜的这么久的博客吧，哪怕水水文章都可以的。但是别把他放弃了。</p>
<p>既然如此，那么我确实也应该更新点东西了。</p>
<h1 id="计划"><a href="#计划" class="headerlink" title="计划"></a>计划</h1><ul>
<li>[ ] STM32的配置，以及工程的文件结构</li>
<li>[ ] GPIO的配置</li>
<li>[ ] 串口的配置和使用</li>
<li>[ ] 单片机的编译原理以及内存管理</li>
<li>[ ] DMA的使用</li>
<li>[ ] 浅谈EC200S4G模块</li>
<li>[ ] hex编码转base64编码的原理以及实现方式</li>
</ul>
<hr>
<p>大概打比赛到现在，真真正正接触到的应该就是只有那么多东西了，当然，自己也并不是就全部都弄懂了写博客的过程中刚好算是再复习一遍吧。</p>
]]></content>
      <categories>
        <category>随笔</category>
      </categories>
  </entry>
  <entry>
    <title>埃及分数</title>
    <url>/2021/11/23/%E9%A2%98%E7%9B%AE/%E5%9F%83%E5%8F%8A%E5%88%86%E6%95%B0/</url>
    <content><![CDATA[<h1 id="题干"><a href="#题干" class="headerlink" title="题干"></a>题干</h1><p>古埃及人只用分子为1的分数，在表示一个真分数时，将其分解为若干个埃及分数之和。例如，7/8表示为 1/2+1/3+1/24。要求把一个真分数表示为最少的埃及分数之和的形式。更加详细的描述请自行百度。</p>
<h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><p>要求表示为最少的埃及分数之和的形式，那就要求我们分解出来得到埃及分数的分母尽可能的小。<br>按照贪心的策略，我们可以在每一次分解时都取出最大的那个埃及分数，也就是分母最小的埃及分数。然后将所给的真分数分解为一个更小的真分数+埃及分数的形式，然后对该真分数继续分解，直到把真分数都表示成埃及分数的形式。<br>那么，现在的问题就转成了怎么求出每次的最大的埃及分数了。下面就行相应分析：</p>
<p>假设一个真分数为$\frac{a}{b}$，那么就有$b&gt;a$,那么，$b$就可以表示成以下形式：</p>
<script type="math/tex; mode=display">
\begin{eqnarray*}
&&b=a*k+c \\
&&\Rightarrow \frac{b}{a}=k+\frac{c}{a} \\
&&\Rightarrow \frac{a}{b}=\frac{1}{k+ \frac{c}{a} },\frac{c}{a}<1\\
&&\Rightarrow \frac{a}{b}=\frac{1}{k+ \frac{c}{a} }>\frac{1}{k+ 1 }
\end{eqnarray*}</script><p>那么，$\frac{a}{b}$的最大埃及分数为$\frac{1}{k+1}$,那么，问题应该就可以解决了。</p>
<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 埃及分数 */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">eg_score</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;a/b =&quot;</span>;</span><br><span class="line">    <span class="keyword">while</span> (a &gt; <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">int</span> k = b / a + <span class="number">1</span>;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;1/&quot;</span> &lt;&lt; k &lt;&lt; <span class="string">&quot;+&quot;</span>;  </span><br><span class="line">        a = a * k - b;   <span class="comment">//求拆解后的分子和分母</span></span><br><span class="line">        b = b * k;</span><br><span class="line">        <span class="keyword">int</span> r = __gcd(a, b);  <span class="comment">//这里是求a,b的最大公约数</span></span><br><span class="line">        <span class="keyword">if</span> (r &gt; <span class="number">1</span>) &#123;          <span class="comment">//将拆解过后的分数化为真分数</span></span><br><span class="line">            a = a / r;</span><br><span class="line">            b = b / r;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;1/&quot;</span> &lt;&lt; b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a, b;</span><br><span class="line">    cin &gt;&gt; a &gt;&gt; b;</span><br><span class="line">    <span class="built_in">eg_score</span>(a, b);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>课本上把这道题的算法归类到<code>贪心</code>应该就是在求最大的埃及分数那一步体现出来的。你要求最少的埃及分数，那就是要求每次分解出来的埃及分数尽可能地大，这样就减少了分解出来的埃及分数的个数。</p>
]]></content>
      <categories>
        <category>题目</category>
      </categories>
      <tags>
        <tag>贪心算法</tag>
      </tags>
  </entry>
  <entry>
    <title>01背包问题</title>
    <url>/2021/11/02/%E9%A2%98%E7%9B%AE/01%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<h1 id="0-1背包问题"><a href="#0-1背包问题" class="headerlink" title="0-1背包问题"></a>0-1背包问题</h1><p>给定<code>n</code>个物品和一个背包，物品$i$$(1\le i \le n )$ 的重量为$w_i$ ,其价值为$v_i$ ,背包容量为<code>c</code> ,对每种物品只有两种选择：装入背包或者不装。如何选择装入背包的物品，使得装入背包的物品的总价值最大？</p>
<h1 id="问题理解"><a href="#问题理解" class="headerlink" title="问题理解"></a>问题理解</h1><p>刚开始是我不是很理解这个容量是什么意思，我以为是能装多少个物品的意思，事实上这个容量的意思是，这个背包所能过装的最大重量。</p>
<p>所以，这个题目的意思是，我这个背包只能装这么重的东西，我要怎么装，才能让我带走的东西价值最高。</p>
<h1 id="思想"><a href="#思想" class="headerlink" title="思想"></a>思想</h1><h2 id="暴力"><a href="#暴力" class="headerlink" title="暴力"></a>暴力</h2><p>我们可以这么想，我们这些物品的子集全部找出来，然后再找出这些子集中重量和不超过<code>c</code> 的，然后从中找到价值最大的子集，然后这个子集上的东西就是我要带走的东西了。<br>但是，我们分析一下就会知道，对于<code>n</code>个物品，它的子集个数为$2^n$ ，也就是说，它是呈指数趋势增长的，如果我们的物品很多，那这样产生的子集巨多，我们还按照上面的想法去干显然很呆。</p>
<h2 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h2><p>然后，老师教我们用动态规划去做，名词听起来就高级，然而我并不能理解动态规划是个什么思想，但这并不影响我去做这道题。也许学多一点以后就会知道了吧。那下面说一下我理解的思路：</p>
<p>我们把这些物品的重量用一个数组存起来，记为$w[i]$</p>
<p>把它们对应的价值也用一个数组存起来，记为$v[i]$ </p>
<h3 id="先找出最大价值是多少"><a href="#先找出最大价值是多少" class="headerlink" title="先找出最大价值是多少"></a>先找出最大价值是多少</h3><p>那下面我们先不考虑选哪些物品的问题，先找出这个最大的价值。</p>
<p>我们这样子定义<code>val(i,j)</code> ,它表示将<code>i</code>个物品装入容量为<code>j</code> 的背包所获得的最大价值，至于装哪些东西进背包才能获得最大价值，这就需要我们进行决策了。很明显，这是我们01背包问题的一个子问题。我们假设前<code>i-1</code>个物品已经决策好了，现在来决策第<code>i</code>个物品，那我们现在是不是就只要考虑要不要把<code>i</code> 装入背包就行了？如果把它装入背包后的价值变大，那我自然是把它装进来呀，是吧。好，那么我们写一下在第<code>i</code> 个位置的决策情况,我们来分析装和不装的情况下的价值：</p>
<ol>
<li>如果当前剩余的容量$&lt;w[i]$,不能装入，当前价值等于前<code>i-1</code> 个物品决策出来的价值，即$val(i-1,j)$</li>
<li>如果剩余容量$&gt;w[i]$，我可以有装入<code>i</code> 和不装这两种选择，我选哪种呢？那肯定做出价值大的那个选择。如果不装的话，当前价值就是：$val(i,j)=val(i-1,j)$ ,也就是当前价值等于前<code>i-1</code> 个物品决策出来的价值。如果选的话，那$val(i,j)=val(i-1,j-w[i])+v[i]$ ,那当前价值相当于把前<code>i-1</code>个物品装入<code>j-w[i]</code> 容量的价值加上这个物品的价值。然后我们取上面两种情况中价值大的作为决策依据。</li>
</ol>
<p>也就是说，对第<code>i</code> 个物品决策时，我的价值的情况如下：</p>
<p><img src="https://i.loli.net/2021/11/06/KMCiXEm53tgph6d.png" alt=" "></p>
<p>好，那我现在得到一条递推式了，我自然而然的就可以推出第<code>i+1</code> 个物品在背包剩余容量已知的情况下的最佳决策，第<code>i+2</code>个物品的在背包剩余容量已知的情况下的最佳决策········一直可以推出，有<code>n</code> 个物品，已知背包剩余容量为<code>c</code> 的情况下的最佳决策，也就是最大价值，这是不是也就解决了我的问题？</p>
<p>其实还有一个问题没有解决，那就是我上面这条公式的起始情况是什么？</p>
<p>不难发现，当我们决策第1 个物品时，我们要依赖前0个物品的决策结果，那我们来看第0个物品怎么决策的，现在有0个物品，要把它们装进容量为<code>j</code> 的背包，怎样装才能价值最大？显然无论怎么装，价值都是0。</p>
<p>还有类似的，我有<code>i</code> 个物品，把它们装入到容量为0的背包，价值当然也是0。那么，起始情况如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">val</span>(<span class="number">0</span>,j)=<span class="number">0</span>;</span><br><span class="line"><span class="built_in">val</span>(i,<span class="number">0</span>)=<span class="number">0</span>;</span><br></pre></td></tr></table></figure>
<p>那由上面的递推关系，我们就可以求得$val(n,c)$的值了。</p>
<h3 id="判断哪些物品被装入了背包"><a href="#判断哪些物品被装入了背包" class="headerlink" title="判断哪些物品被装入了背包"></a>判断哪些物品被装入了背包</h3><p>上面我们的到了决策的最大价值，那下面我们来看看到底那些物品被我们装入了背包：</p>
<p>我们回顾上面的内容，我们会发现，对于每一个<code>val(i,j)</code>的值，我是不是都可以通过前一个物品的决策结果得到，也就是说，对于每一个<code>val(i,j)</code> ，我是不是都要存着，方便下一个物品决策时参考？那我们用一个二维数组来存它们就刚刚好。</p>
<p>那经过上面那些决策，我们的二维数组<code>val[n+1][c+1]</code>是不是就已经填好了？注意了，我这里数组大小为什么是<code>n+1</code>和<code>c+1</code> ,因为我们上面把第0个物品和背包容量为0，都算作正常情况，那0个物品也算作一种情况。当然，你也可以把它看作是一种初始化，我这么讲是为了方便理解。</p>
<p>好，那我的二维表已经填好了。那我们来判断第<code>i</code> 个物品有没有装入到背包中，那我们是不是可以比较一下前<code>i-1</code>个物品在背包容量为<code>j</code>时决策所得的价值和前<code>i</code> 个物品在同种情况下的价值大小？如果<code>val(i,j)=val(i-1,j)</code>是不是说明，第<code>i</code>个物体没有被装入背包啊,因为如果装入的话，它的价值应该是比前一个大的。那么，我从后往前推是不是就可以判断出哪些物品被装入了背包，哪些没有？那到此为止，问题就解决了。</p>
<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n, c;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; c;</span><br><span class="line">    <span class="keyword">int</span> w[n], v[n];</span><br><span class="line">    <span class="keyword">int</span> val[n + <span class="number">1</span>][c + <span class="number">1</span>];</span><br><span class="line">    <span class="built_in">memset</span>(val, <span class="number">0</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(val));         <span class="comment">//val(0,j)=val(i,0)=0，这里全初始化为0了</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        cin &gt;&gt; w[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        cin &gt;&gt; v[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= c; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (j &lt; w[i])</span><br><span class="line">                val[i][j] = val[i - <span class="number">1</span>][j];</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                val[i][j] = <span class="built_in">max</span>(val[i - <span class="number">1</span>][j], val[i - <span class="number">1</span>][j - w[i]] + v[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> x[n];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = c, i = n; i &gt; <span class="number">0</span>; i--) &#123;</span><br><span class="line">        <span class="keyword">if</span> (val[i][j] &gt; val[i - <span class="number">1</span>][j]) &#123;</span><br><span class="line">            x[i] = <span class="number">1</span>;</span><br><span class="line">            j = j - w[i];      <span class="comment">//判断被装入了，减掉它的容量，用于判断前面的物体是否被装入</span></span><br><span class="line">        &#125; <span class="keyword">else</span></span><br><span class="line">            x[i] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; val[n][c] &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        cout &lt;&lt; x[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h1 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h1><p> 主要算那个二重循环那里，时间复杂度就是： $O(n*c)$</p>
<h1 id="相关题目"><a href="#相关题目" class="headerlink" title="相关题目"></a>相关题目</h1><p>在<code>acwing</code> 上，我刚好看到一道01背包的简单题，和上面的题目一样。感觉懂了的话可以去当作练习试一下，题目链接：<a href="https://www.acwing.com/problem/content/2/">https://www.acwing.com/problem/content/2/</a></p>
<h1 id="参考内容"><a href="#参考内容" class="headerlink" title="参考内容"></a>参考内容</h1><p>链接：<a href="https://space.bilibili.com/501486236?spm_id_from=333.788.b_765f7570696e666f.1">https://space.bilibili.com/501486236?spm_id_from=333.788.b_765f7570696e666f.1</a></p>
<p>特别感谢这个老师的讲解，让我理解了背包问题的解决过程，如果看不懂这篇博客的话，可以去看看这个视频</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ol>
<li>经过这篇博客的写作，我好像有一点理解动态规划是个什么概念了，大概就是当前的决策问题要依靠前面的决策结果才能作出决策，然后通过递推关系式能够得到最终的结果，这个好像又有点像递归，有点分不清。我想大概思想就是尽可能地利用中间过程的结果为下一步决策。具体的还没有搞懂。</li>
<li>虽然有点理解背包问题了，但是用文字描述出来总感觉怪怪的，好像就是有点表达不清楚的样子，尤其是推最大价值那部分。希望以后能进一步改进一下，有大佬理解的话还希望能够点拨一下，万分感谢。</li>
<li>在编码过程中要注意对数据进行初始化，不然会有你意想不到的结果，还有就是数组不要越界，这同样会发生不可预估的错误。在定义和使用<code>w[n]</code>和<code>v[n]</code>以及<code>val[n+1][c+1]</code>时尤其要注意，从<code>+1</code> 这个操作应该就会想到了。</li>
</ol>
]]></content>
      <categories>
        <category>题目</category>
      </categories>
      <tags>
        <tag>0-1背包问题</tag>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title>最大子段和问题</title>
    <url>/2021/11/08/%E9%A2%98%E7%9B%AE/%E6%9C%80%E5%A4%A7%E5%AD%90%E6%AE%B5%E5%92%8C/</url>
    <content><![CDATA[<h1 id="最大子段和"><a href="#最大子段和" class="headerlink" title="最大子段和"></a>最大子段和</h1><p>问题： 给定n个整数（可能为负数）组成的序列a[1],a[2],a[3],…,a[n],求该序列如a[i]+a[i+1]+…+a[j]的子段和的最大值。当所给的整数均为负数时定义子段和为0，依此定义，所求的最优值为： Max{0,a[i]+a[i+1]+…+a[j]},1&lt;=i&lt;=j&lt;=n 例如，当a[]=(-20,11,-4,13,-5,-2)时，最大子段和为20。</p>
<blockquote>
<p>以上内容来自百度百科</p>
</blockquote>
<h1 id="思想1：递归思想"><a href="#思想1：递归思想" class="headerlink" title="思想1：递归思想"></a>思想1：递归思想</h1><p>分析这个问题，我们可以这么想：<br>我们把给定的数组搞一条中线出来，设它为mid吧，然后 把它分成两部分，对于这个最大子段和，它有可能出现的地方有多少种情况呢?</p>
<ol>
<li>出现在左边部分,也就是左边的最大子段和大于右边</li>
<li>出现在右边部分，和上面相反</li>
<li>出现在中间部分，也就是中线被夹在中间 </li>
</ol>
<p>那么，用二分的思想来做，我们是不是可以对左边同样执行上面的步骤，直到只有一个元素了，也就是到达了base case的地步了，这时候我就把这个值返回，然后走右边的。等到两边都走完了，我再看看中间这种情况，然后找出这三者当中大的那个返回给上一级。</p>
<p>我再细讲一下中间情况下是怎么处理的：</p>
<p>既然最大子段和出现再中间位置，那么是不是说，它有一部分数据在中线的左边，一部分数据出现在中线的右边呀？那么，我分别求出中线往左的数的和的最大值，以及中线往右的数的和的最大值，最后把它们加到一起，是不是就是我中间这种情况出现的最大子段和了？</p>
<p>好，那下面上代码看看：</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">max_sub_sum</span><span class="params">(<span class="keyword">int</span> arr[], <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (l == r)</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">max</span>(arr[l], <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">int</span> mid = l + (r - l) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">int</span> lres = <span class="built_in">max_sub_sum</span>(arr, l, mid);      <span class="comment">//找出左边最大的子段和</span></span><br><span class="line">        <span class="keyword">int</span> rres = <span class="built_in">max_sub_sum</span>(arr, mid + <span class="number">1</span>, r);  <span class="comment">//找出右边最大的子段和</span></span><br><span class="line">        <span class="keyword">int</span> lmax = <span class="number">0</span>, rmax = <span class="number">0</span>, sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = mid; i &gt;= l; i--) &#123;          <span class="comment">//找出中线左边的数的和最大值</span></span><br><span class="line">            sum += arr[i];</span><br><span class="line">            lmax = <span class="built_in">max</span>(sum, lmax);</span><br><span class="line">        &#125;</span><br><span class="line">        sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = mid + <span class="number">1</span>; i &lt;= r; i++) &#123;      <span class="comment">//中线右边的数的和最大值</span></span><br><span class="line">            sum += arr[i];</span><br><span class="line">            rmax = <span class="built_in">max</span>(sum, rmax);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> midres = lmax + rmax;                 <span class="comment">//两边加起来就是中间情况下的最大子段和</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">max</span>(<span class="built_in">max</span>(lres, rres), midres);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="时间复杂度分析"><a href="#时间复杂度分析" class="headerlink" title="时间复杂度分析"></a>时间复杂度分析</h2><p>$T(n)=2T(\frac{n}{2})+2O(n)+O(1)$</p>
<p>由<code>master</code>公式，$a=2,b=2,d=1\to\log_ba=1=d$ 则时间复杂度：</p>
<script type="math/tex; mode=display">T(n)=O(n*log{n})</script><p> 不知道<code>master</code>的可以到<code>时间复杂度</code>这篇博文中进行查看，附上链接：<a href="/2021/10/30/%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80/%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6/" title="时间复杂度">时间复杂度</a></p>
<h1 id="思想2：动态规划（补充）"><a href="#思想2：动态规划（补充）" class="headerlink" title="思想2：动态规划（补充）"></a>思想2：动态规划（补充）</h1><p>在学了动态规划之后，老师还是给我们布置了这一道题，但是它叫最大子序和问题，刚开始我还以为是什么东西，后来想想，发现还是最大子段和问题，只不过现在它换了一种方法做，那就是动态规划。</p>
<p>我们看分治法可以发现，在它求解中间部分的最大子段和问题的时候，他还是用了枚举的这种方法，也就是说，它依然是重复执行了前面遍历过的东西。那我们可以想一种方法，怎么样才能尽可能大的利用我前面走过的数据用于后面的决策？</p>
<p>我们重新想这个问题，我们这个问题是不是相当于求长度为n的序列的最大子序和？</p>
<p>那我们拆分一下这个问题，或者说转换为更加一般的问题求解：</p>
<p>我们求长度为<code>i</code> 的最大子序和，或者说求已知序列前<code>i</code> 个数字的最大子序和。</p>
<p>那我们这样子想，求长度为<code>i</code> 的最大子序和，是不是可以利用前<code>i-1</code>个长度的序列的最大子序和以及当前位置上的数值<code>a[i]</code> 做出决策？我们设<code>d[i]</code>表示前<code>i</code> 个长度的序列的最大子序和，那么，像上面说的那样，求<code>d[i]</code>时可以利用<code>d[i-1]</code>做出决策，那么<code>d[i]</code> 有如下两种情况：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">d[i]=d[i<span class="number">-1</span>]+a[i] ,d[i<span class="number">-1</span>]&lt;<span class="number">0</span></span><br><span class="line">d[i]=a[i]        ,d[i<span class="number">-1</span>]&gt;=<span class="number">0</span></span><br></pre></td></tr></table></figure>
<p>这个也很好理解，如果前面的最大子序和为负数了，那$d[i-1]+a[i]&lt;a[i]$，那我还不如那<code>a[i]</code>作为我当前的最大子序和呢！理解了之后，代码也很简单。</p>
<h2 id="动态规划代码"><a href="#动态规划代码" class="headerlink" title="动态规划代码"></a>动态规划代码</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 最大子序（段）和 */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">1e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> arr[N],d[N],n;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        cin &gt;&gt; arr[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(d[i<span class="number">-1</span>]&lt;=<span class="number">0</span>)&#123;</span><br><span class="line">            d[i]=arr[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            d[i]=d[i<span class="number">-1</span>]+arr[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> maxn=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        maxn=<span class="built_in">max</span>(maxn,d[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; maxn;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>时间复杂度:$O(n)$</p>
<h2 id="改进"><a href="#改进" class="headerlink" title="改进"></a>改进</h2><p>上面的内容有一个大前提，那就是所给的数组不能全部为负数，但是经过刷题，我发现别人的要求中是没有这一点的，所以，要进行改进，针对全部的数组，都可以返回一个最大子序和。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 最大子序（段）和 */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">1e6</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> arr[N],n;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">        cin &gt;&gt; arr[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> pre=arr[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">int</span> maxn=arr[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;n;i++)&#123;</span><br><span class="line">        pre=<span class="built_in">max</span>(pre+arr[i],arr[i]);</span><br><span class="line">        maxn=<span class="built_in">max</span>(maxn,pre);</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; maxn;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p>洛谷：<a href="https://www.luogu.com.cn/problem/P1115">https://www.luogu.com.cn/problem/P1115</a></p>
<p>Leetcode:  <a href="https://leetcode-cn.com/problems/lian-xu-zi-shu-zu-de-zui-da-he-lcof/submissions/">https://leetcode-cn.com/problems/lian-xu-zi-shu-zu-de-zui-da-he-lcof/submissions/</a></p>
]]></content>
      <categories>
        <category>题目</category>
      </categories>
      <tags>
        <tag>动态规划</tag>
        <tag>分治法</tag>
      </tags>
  </entry>
  <entry>
    <title>最短编辑距离</title>
    <url>/2021/11/09/%E9%A2%98%E7%9B%AE/%E6%9C%80%E7%9F%AD%E7%BC%96%E8%BE%91%E8%B7%9D%E7%A6%BB/</url>
    <content><![CDATA[<h1 id="题干"><a href="#题干" class="headerlink" title="题干"></a>题干</h1><p>来源：<a href="https://www.luogu.com.cn/problem/P2758">https://www.luogu.com.cn/problem/P2758</a></p>
<p><img src="https://i.loli.net/2021/11/09/qemuX2w4RHoGQcv.png" alt="image-20211109110047319"></p>
<h1 id="思路：动态规划"><a href="#思路：动态规划" class="headerlink" title="思路：动态规划"></a>思路：动态规划</h1><h2 id="推导"><a href="#推导" class="headerlink" title="推导"></a>推导</h2><p>要实现将<code>A</code>转换为 <code>B</code>，那也就是对<code>A</code>进行操作，那么，我们设<code>dp[i-1][j-1]</code>为串<code>A</code>的前<code>i-1</code>个字符转换为<code>B</code> 的前<code>j-1</code>个字符的最少操作数，那么，如何求解<code>dp[i][j]</code>？求解出这个，是不是就可以求出<code>dp[n][m]</code>了？（这里假设<code>A</code> 的长度为<code>n</code> ，<code>B</code>的长度为<code>m</code>）,好，那我们来分析一下:</p>
<p>如果<code>a[i]==b[j]</code> ，那么是不是不用进行操作？则<code>dp[i][j]=dp[i-1][j-1]</code></p>
<p>如果不等的话，我们要怎么办呢？那是不是要对<code>A</code> 进行<code>增</code>, <code>删</code>, <code>改</code>操作?然后我们取其中最小的值作为该步骤的最小操作。那我们来分析一下各种情况：</p>
<ol>
<li>替换。这种情况是不是只要将<code>A[i]</code>的值替换为<code>B[j]</code>就能使<code>A</code>和<code>B</code>相等了。所以此时的最小操作数等于<code>i-1</code>个长度的操作数+1，即 <code>dp[i][j]=dp[i-1][j-1]+1</code></li>
<li>增加。如图，如果<code>A</code>串的长度小于<code>B</code>串，那这时我是不是要在<code>A</code>串的末尾加上一个字符才能和<code>B</code>相等，所以操作数=<code>A</code>的前<code>i</code>个字符和<code>B</code>的前<code>j-1</code>个字符匹配的最小操作数+1，即<code>dp[i][j]=d[i][j-1]+1</code></li>
<li>删除。同上类推</li>
</ol>
<p><img src="https://i.loli.net/2021/11/09/8Yaw2ZUIQHsT4Au.jpg" alt="img"></p>
<h2 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h2><p><code>dp</code>数组的初始化就是<code>A</code> 为空的时候，那么<code>A</code>要执行的最小操作就是把<code>B</code> 的字符拷贝过来，即<code>d[0][j]=j</code></p>
<p>同样的，<code>B</code>为空的时候，就要把<code>A</code>的内容删掉,<code>dp[i][0]=1</code></p>
<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">int</span> dp[<span class="number">2000</span> + <span class="number">10</span>][<span class="number">2000</span> + <span class="number">10</span>];</span><br><span class="line"><span class="keyword">char</span> a[<span class="number">2000</span> + <span class="number">10</span>], b[<span class="number">2000</span> + <span class="number">10</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%s %s&quot;</span>, a, b);</span><br><span class="line">    <span class="keyword">int</span> n = <span class="built_in">strlen</span>(a), m = <span class="built_in">strlen</span>(b);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        dp[i][<span class="number">0</span>] = i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++) &#123;</span><br><span class="line">        dp[<span class="number">0</span>][i] = i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= m; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (a[i - <span class="number">1</span>] == b[j - <span class="number">1</span>])  <span class="comment">//字符串数组从0开始,所以第i个字符为a[i-1]</span></span><br><span class="line">                dp[i][j] = dp[i - <span class="number">1</span>][j - <span class="number">1</span>];</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                dp[i][j] =</span><br><span class="line">                    <span class="built_in">min</span>(<span class="built_in">min</span>(dp[i][j - <span class="number">1</span>], dp[i - <span class="number">1</span>][j - <span class="number">1</span>]), dp[i - <span class="number">1</span>][j]) + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; dp[n][m];</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>时间复杂度：$O(n*m)$</p>
]]></content>
      <categories>
        <category>题目</category>
      </categories>
      <tags>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title>最长公共子串</title>
    <url>/2021/11/23/%E9%A2%98%E7%9B%AE/%E6%9C%80%E9%95%BF%E5%85%AC%E5%85%B1%E5%AD%90%E4%B8%B2/</url>
    <content><![CDATA[<h1 id="废话"><a href="#废话" class="headerlink" title="废话"></a>废话</h1><p>这是本人期中考试的一道题目，本人以为最后已经做出来了（<del>由于学校的评测系统压力太大，到交卷也还在等待评测</del>），一直想补一下这道题，但是拖到现在才想起来。</p>
<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p>现在只能记得一个大概，下面全是个人回忆：</p>
<p>题目大意是这样子的：</p>
<p>总的要求是，给出两个串，要求输出它们的最大的公共子串长度。</p>
<p>具体的输入输出如下：</p>
<h3 id="输入"><a href="#输入" class="headerlink" title="输入"></a>输入</h3><p>第一行输入数字k,代表要进行k次比较</p>
<p>第二行输入两个字符串a,b</p>
<h3 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h3><p>k 行，分别表示各对串的最长公共子串长度</p>
<h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><p>这是一个动态规划的题目，做法与 <a href="/2021/11/09/%E9%A2%98%E7%9B%AE/%E6%9C%80%E7%9F%AD%E7%BC%96%E8%BE%91%E8%B7%9D%E7%A6%BB/" title="最短编辑距离">最短编辑距离</a> 那一题相似，还比那一题要简单一些，但是为什么考试时我没做出来，我也说不上来（<del>不想承认自己菜的事实</del>）。下面说思路：</p>
<p>最大公共子串长度，给出两个串，当时我自然而然就想到了和最短编辑距离那一题相似。</p>
<p>用<code>dp[i][j]</code>表示<code>a</code>的前<code>i</code>个字串和<code>b</code>的前<code>j</code>个字串的公共子串长度。</p>
<p>我们假设<code>a</code>的前<code>i-1</code>个字符和<code>b</code>的前<code>j-1</code>个字符已经比较好了，现在来决策<code>i</code>和<code>j</code>：</p>
<ol>
<li>如果当前<code>a[i]==b[j]</code>,那么公共子串长度=<code>dp[i-1][j-1]+1</code></li>
<li>如果不等，那么<code>dp[i][j]=0</code>，为什么？因为是公共子串，你到这里不等了，自然也就不能用前面的数据了，这能从头算起了。</li>
</ol>
<p>所以，该过程的状态转移方程为：</p>
<p><img src="https://i.loli.net/2021/11/23/Qzbgw4jtqRvLdyS.png" alt="image-20211123202741048"></p>
<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 最长公共子串 */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e3</span>;</span><br><span class="line"><span class="keyword">int</span> dp[N][N],k;</span><br><span class="line"><span class="keyword">char</span> a[N], b[N];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cin &gt;&gt; k;</span><br><span class="line">    <span class="keyword">while</span>(k&gt;<span class="number">0</span>)&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%s %s&quot;</span>, a, b);</span><br><span class="line">    <span class="keyword">int</span> n = <span class="built_in">strlen</span>(a), m = <span class="built_in">strlen</span>(b);</span><br><span class="line">    <span class="keyword">int</span> ans=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= m; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (a[i<span class="number">-1</span>] != b[j<span class="number">-1</span>])               <span class="comment">//注意此处，字符串是从0开始的，所以要-1</span></span><br><span class="line">                dp[i][j] = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                dp[i][j] = dp[i - <span class="number">1</span>][j - <span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            ans=<span class="built_in">max</span>(ans,dp[i][j]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">    k--;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>现在回想起来感觉自己错的地方可能是错在那个<code>a[i-1]!=b[j-1]</code>那里，导致一直查不出来具体是哪里错了，总感觉自己没错，但是结果不正确。当然，上面的题解也未必正确，毕竟也没有验证过！</p>
<p>所以，写代码的时候一定要注意这种数组边界的地方，一不小心就会吃大亏。</p>
<p>好吧，那就到此为止吧！</p>
]]></content>
      <categories>
        <category>题目</category>
      </categories>
      <tags>
        <tag>动态规划</tag>
      </tags>
  </entry>
</search>
